You are a senior software engineer with deep expertise in design patterns and code refactoring.
Your task is to refactor the provided code by applying the specified design pattern while ensuring all tests pass and the code’s original functionality remains intact.
You will receive a detailed task, the original code, the design pattern to apply, and the associated tests.

<task>
Apply the state design pattern based on the description provided.
Preserve the original behavior; all tests must pass after refactoring.
Do not rename any classes, functions, or modules in a way that would break existing import statements in the tests.
Follow existing code style and naming conventions where possible.
If applying the pattern exactly as described would break the tests or result in worse code design, adapt it thoughtfully to fit the context while preserving the spirit of the pattern.
</task>

<code>
from abc import ABC, abstractmethod


class Stall:
    def __init__(self):
        self.state = FreeState(self)
    
    def set_state(self, state):
        self.state = state
    
    def assign(self): 
        if isinstance(self.state, FreeState):
            print("Stall assigned.")
            self.set_state(OccupiedState(self))
        elif isinstance(self.state, OccupiedState):
            raise Exception("Cannot assign while occupied.")
        elif isinstance(self.state, OccupiedMaintenanceState):
            raise Exception("Cannot assign. Stall is under maintenance.")
        elif isinstance(self.state, FreeMaintenanceState):
            raise Exception("Cannot assign. Stall is under maintenance.")
    
    def end_market(self):
        if isinstance(self.state, FreeState):
            raise Exception("Market is not running.")
        elif isinstance(self.state, OccupiedState):
            print("Market ended. Moving to free state.")
            self.set_state(FreeState(self))
        elif isinstance(self.state, FreeMaintenanceState):
            raise Exception("Market is not running.")
        elif isinstance(self.state, OccupiedMaintenanceState):
            print("Market ended, changing maintenance.")
            self.set_state(FreeMaintenanceState(self))
    
    def report_issue(self):
        if isinstance(self.state, FreeState):
            print("Issue reported. Moving to maintenance.")
            self.set_state(FreeMaintenanceState(self))
        elif isinstance(self.state, OccupiedState):
            print("Issue reported. Moving to maintenance.")
            self.set_state(OccupiedMaintenanceState(self))
        elif isinstance(self.state, OccupiedMaintenanceState):
            raise Exception("Already under maintenance.")
        elif isinstance(self.state, FreeMaintenanceState):
            raise Exception("Already under maintenance.")
    
    def finish_maintenance(self):
        if isinstance(self.state, FreeState):
            raise Exception("Already in a free state.")
        elif isinstance(self.state, OccupiedState):
            raise Exception("Cannot finish maintenance in occupied state.")
        elif isinstance(self.state, FreeMaintenanceState):
            print("Maintenance finished. Moving to free state.")
            self.set_state(FreeState(self))
        elif isinstance(self.state, OccupiedMaintenanceState):
            print("Maintenance finished. Moving to occupied state.")
            self.set_state(OccupiedState(self))


# State Classes
class StallState(ABC):
    def __init__(self, stall):
        self.stall = stall


class FreeState(StallState):
    def __init__(self, stall):
        super().__init__(stall)
    

class OccupiedState(StallState):
    def __init__(self, stall):
        super().__init__(stall)


class FreeMaintenanceState(StallState):
    def __init__(self, stall):
        super().__init__(stall)


class OccupiedMaintenanceState(StallState):
    def __init__(self, stall):
        super().__init__(stall)

</code>

<designPatternName>
state
</designPatternName>

<designPatternDescription>
Intent
Allow an object to alter its behavior when its internal state changes.The object
will appear to change its class.
Motivation
Consider a class TCPConnection that represents a network connection.A
TCPConnection object can be in one of several different states:Established,
Listening, Closed. When a TCPConnection object receivesrequests from other objects,
it responds differently depending on itscurrent state. For example, the effect
of an Open request depends onwhether the connection is in its Closed state or
its Establishedstate. The State pattern describes how TCPConnection can
exhibitdifferent behavior in each state.
The key idea in this pattern is to introduce an abstract class calledTCPState
to represent the states of the network connection. TheTCPState class declares
an interface common to all classes thatrepresent different operational states.
Subclasses of TCPStateimplement state-specific behavior. For example, the
classesTCPEstablished and TCPClosed implement behavior particular to
theEstablished and Closed states of TCPConnection.
The class TCPConnection maintains a state object (an instance of asubclass of
TCPState) that represents the current state of the TCPconnection. The class
TCPConnection delegates all state-specificrequests to this state object.
TCPConnection uses its TCPStatesubclass instance to perform operations particular
to the state of theconnection.
Whenever the connection changes state, the TCPConnection objectchanges the state
object it uses. When the connection goes fromestablished to closed, for example,
TCPConnection will replace itsTCPEstablished instance with a TCPClosed instance.
Structure
@startuml
title State Pattern
' Context
class Context {
    -state: State
    +setState(s: State): void
    +request(): void
}
' State Interface
interface State {
    +handle(context: Context): void
}
' Concrete States
class ConcreteStateA implements State {
    +handle(context: Context): void
}
class ConcreteStateB implements State {
    +handle(context: Context): void
}
' Relationships
Context --> State : "has a"
@enduml
Participants
· Context (TCPConnection)
o defines the interface of interest to clients.
o maintains an instance of a ConcreteState subclass that defines
thecurrent state.
· State (TCPState)
o defines an interface for encapsulating the behavior associated with
aparticular state of the Context.
· ConcreteState subclasses (TCPEstablished, TCPListen, TCPClosed)
o each subclass implements a behavior associated with a state ofthe
Context.
Collaborations
· Context delegates state-specific requests to the current
ConcreteStateobject.
· A context may pass itself as an argument to the State objecthandling the
request. This lets the State object accessthe context if necessary.
· Context is the primary interface for clients. Clients can configure acontext
with State objects. Once a context is configured, its clients don't have
to deal with the State objects directly.
· Either Context or the ConcreteState subclasses can decide which
statesucceeds another and under what circumstances.
Implementation
The State pattern raises a variety of implementation issues:
1. Who defines the state transitions?The State pattern does not specify which
participant defines thecriteria for state transitions. If the criteria are
fixed, then theycan be implemented entirely in the Context. It is generally
moreflexible and appropriate, however, to let the State
subclassesthemselves specify their successor state and when to make
thetransition. This requires adding an interface to the Context thatlets
State objects set the Context's current state explicitly.
Decentralizing the transition logic in this way makes it easy tomodify or
extend the logic by defining new State subclasses. Adisadvantage of
decentralization is that one State subclass will haveknowledge of at least
one other, which introduces implementationdependencies between
subclasses.
2. A table-based alternative.In C++ Programming Style [Car92],
Cargilldescribes another way to impose structure on state-driven code:
Heuses tables to map inputs to state transitions. For each state, atable
maps every possible input to a succeeding state. In effect,this approach
converts conditional code (and virtual functions, in thecase of the State
pattern) into a table look-up.
The main advantage of tables is their regularity: You can change
thetransition criteria by modifying data instead of changing programcode.
There are some disadvantages, however:
o A table look-up is often less efficient than a (virtual)function
call.
o Putting transition logic into a uniform, tabular format makes
thetransition criteria less explicit and therefore harder to
understand.
o It's usually difficult to add actions to accompany the
statetransitions. The table-driven approach captures the states and
theirtransitions, but it must be augmented to perform arbitrary
computationon each transition.
The key difference between table-driven state machines and the Statepattern
can be summed up like this: The State pattern modelsstate-specific behavior,
whereas the table-driven approach focuses ondefining state transitions.
3. Creating and destroying State objects.A common implementation trade-off
worth considering is whether(1) to create State objects only when they are
needed and destroy themthereafter versus (2) creating them ahead of time
and neverdestroying them.
The first choice is preferable when the states that will be enteredaren't
known at run-time, and contexts change stateinfrequently. This approach
avoids creating objects that won't beused, which is important if the State
objects store a lot ofinformation. The second approach is better when state
changes occurrapidly, in which case you want to avoid destroying states,
becausethey may be needed again shortly. Instantiation costs are paid
onceup-front, and there are no destruction costs at all. This approachmight
be inconvenient, though, because the Context must keepreferences to all
states that might be entered.
4. Using dynamic inheritance.Changing the behavior for a particular request
could be accomplishedby changing the object's class at run-time, but this
is not possiblein most object-oriented programming languages. Exceptions
includeSelf [US87] and other delegation-based languages thatprovide such
a mechanism and hence support the State pattern directly.Objects in Self
can delegate operations to other objects to achieve aform of dynamic
inheritance. Changing the delegation target atrun-time effectively changes
the inheritance structure. Thismechanism lets objects change their
behavior and amounts to changingtheir class.
Sample Code
---
The following example gives the C++ code for the TCP connection example described in the *Motivation* section. This example is a simplified version of the TCP protocol; it doesn't describe the complete protocol or all the states of TCP connections.
---
First, we define the class `TCPConnection`, which provides an interface for transmitting data and handles requests to change state.
```cpp
class TCPOctetStream;
class TCPState;
class TCPConnection {
public:
    TCPConnection();
    void ActiveOpen();
    void PassiveOpen();
    void Close();
    void Send();
    void Acknowledge();
    void Synchronize();
    void ProcessOctet(TCPOctetStream*);
private:
    friend class TCPState;
    void ChangeState(TCPState*);
private:
    TCPState* _state;
};
```
`TCPConnection` keeps an instance of the `TCPState` class in the `_state` member variable. The class `TCPState` duplicates the state-changing interface of `TCPConnection`. Each `TCPState` operation takes a `TCPConnection` instance as a parameter, letting `TCPState` access data from `TCPConnection` and change the connection's state.
```cpp
class TCPState {
public:
    virtual void Transmit(TCPConnection*, TCPOctetStream*);
    virtual void ActiveOpen(TCPConnection*);
    virtual void PassiveOpen(TCPConnection*);
    virtual void Close(TCPConnection*);
    virtual void Synchronize(TCPConnection*);
    virtual void Acknowledge(TCPConnection*);
    virtual void Send(TCPConnection*);
protected:
    void ChangeState(TCPConnection*, TCPState*);
};
```
`TCPConnection` delegates all state-specific requests to its `TCPState` instance `_state`. `TCPConnection` also provides an operation for changing this variable to a new `TCPState`. The constructor for `TCPConnection` initializes the object to the `TCPClosed` state (defined later).
```cpp
TCPConnection::TCPConnection () {
    _state = TCPClosed::Instance();
}
void TCPConnection::ChangeState (TCPState* s) {
    _state = s;
}
void TCPConnection::ActiveOpen () {
    _state->ActiveOpen(this);
}
void TCPConnection::PassiveOpen () {
    _state->PassiveOpen(this);
}
void TCPConnection::Close () {
    _state->Close(this);
}
void TCPConnection::Acknowledge () {
    _state->Acknowledge(this);
}
void TCPConnection::Synchronize () {
    _state->Synchronize(this);
}
```
`TCPState` implements default behavior for all requests delegated to it. It can also change the state of a `TCPConnection` with the `ChangeState` operation. `TCPState` is declared a friend of `TCPConnection` to give it privileged access to this operation.
```cpp
void TCPState::Transmit (TCPConnection*, TCPOctetStream*) { }
void TCPState::ActiveOpen (TCPConnection*) { }
void TCPState::PassiveOpen (TCPConnection*) { }
void TCPState::Close (TCPConnection*) { }
void TCPState::Synchronize (TCPConnection*) { }
void TCPState::ChangeState (TCPConnection* t, TCPState* s) {
    t->ChangeState(s);
}
```
Subclasses of `TCPState` implement state-specific behavior. A TCP connection can be in many states: Established, Listening, Closed, etc., and there's a subclass of `TCPState` for each state. We'll discuss three subclasses in detail: `TCPEstablished`, `TCPListen`, and `TCPClosed`.
```cpp
class TCPEstablished : public TCPState {
public:
    static TCPState* Instance();
    virtual void Transmit(TCPConnection*, TCPOctetStream*);
    virtual void Close(TCPConnection*);
};
class TCPListen : public TCPState {
public:
    static TCPState* Instance();
    virtual void Send(TCPConnection*);
    // ...
};
class TCPClosed : public TCPState {
public:
    static TCPState* Instance();
    virtual void ActiveOpen(TCPConnection*);
    virtual void PassiveOpen(TCPConnection*);
    // ...
};
```
`TCPState` subclasses maintain no local state, so they can be shared, and only one instance of each is required. The unique instance of each `TCPState` subclass is obtained by the static `Instance` operation.
Each `TCPState` subclass implements state-specific behavior for valid requests in the state:
```cpp
void TCPClosed::ActiveOpen (TCPConnection* t) {
    // send SYN, receive SYN, ACK, etc.
    ChangeState(t, TCPEstablished::Instance());
}
void TCPClosed::PassiveOpen (TCPConnection* t) {
    ChangeState(t, TCPListen::Instance());
}
void TCPEstablished::Close (TCPConnection* t) {
    // send FIN, receive ACK of FIN
    ChangeState(t, TCPListen::Instance());
}
void TCPEstablished::Transmit (TCPConnection* t, TCPOctetStream* o) {
    t->ProcessOctet(o);
}
void TCPListen::Send (TCPConnection* t) {
    // send SYN, receive SYN, ACK, etc.
    ChangeState(t, TCPEstablished::Instance());
}
```
After performing state-specific work, these operations call the `ChangeState` operation to change the state of the `TCPConnection`. `TCPConnection` itself doesn't know a thing about the TCP connection protocol; it's the `TCPState` subclasses that define each state transition and action in TCP.
---
</description>
</designPatternDescription>

<tests>
import pytest
from refactored.Stall import *

# Test case for the initial FreeState
def test_initial_state():
    stall = Stall()
    assert isinstance(stall.state, FreeState)

# Test transition from FreeState -> OccupiedState on assign
def test_free_to_occupied_on_assign():
    stall = Stall()
    stall.assign()
    assert isinstance(stall.state, OccupiedState)

# Test transition from FreeState -> FreeMaintenanceState on report_issue
def test_free_to_free_maintenance_on_report_issue():
    stall = Stall()
    stall.report_issue()
    assert isinstance(stall.state, FreeMaintenanceState)

# Test transition from OccupiedState -> FreeState on end_market
def test_occupied_to_free_on_end_market():
    stall = Stall()
    stall.set_state(OccupiedState(stall))  # Moving to OccupiedState first
    stall.end_market()
    assert isinstance(stall.state, FreeState)

# Test transition from OccupiedState -> OccupiedMaintenanceState on report_issue
def test_occupied_to_occupied_maintenance_on_report_issue():
    stall = Stall()
    stall.set_state(OccupiedState(stall))  # Moving to OccupiedState first
    stall.report_issue()
    assert isinstance(stall.state, OccupiedMaintenanceState)

# Test transition from OccupiedMaintenanceState -> OccupiedState on finish_maintenance
def test_occupied_maintenance_to_occupied_on_finish_maintenance():
    stall = Stall()
    stall.set_state(OccupiedMaintenanceState(stall))  # Moving to OccupiedMaintenanceState first
    stall.finish_maintenance()
    assert isinstance(stall.state, OccupiedState)

# Test transition from OccupiedMaintenanceState -> FreeMaintenanceState on end_market
def test_occupied_maintenance_to_free_maintenance_on_end_market():
    stall = Stall()
    stall.set_state(OccupiedMaintenanceState(stall))  # Moving to OccupiedMaintenanceState first
    stall.end_market()
    assert isinstance(stall.state, FreeMaintenanceState)

# Test transition from FreeMaintenanceState -> FreeState on finish_maintenance
def test_free_maintenance_to_free_on_finish_maintenance():
    stall = Stall()
    stall.set_state(FreeMaintenanceState(stall))  # Moving to FreeMaintenanceState first
    stall.finish_maintenance()
    assert isinstance(stall.state, FreeState)

# Test invalid transition: FreeState -> end_market should raise Exception
def test_free_to_free_on_end_market():
    stall = Stall()
    with pytest.raises(Exception, match="Market is not running."):
        stall.end_market()
    assert isinstance(stall.state, FreeState)

# Test invalid transition: OccupiedState -> end_market should move to FreeState
def test_occupied_to_free_on_end_market():
    stall = Stall()
    stall.set_state(OccupiedState(stall))  # Moving to OccupiedState first
    stall.end_market()
    assert isinstance(stall.state, FreeState)

# Test invalid transition: OccupiedState -> finish_maintenance should raise Exception
def test_occupied_finish_maintenance_invalid():
    stall = Stall()
    stall.set_state(OccupiedState(stall))  # Moving to OccupiedState first
    with pytest.raises(Exception, match="Cannot finish maintenance in occupied state."):
        stall.finish_maintenance()
    assert isinstance(stall.state, OccupiedState)

# Test invalid transition: OccupiedMaintenanceState -> report_issue should raise Exception
def test_occupied_maintenance_report_issue_invalid():
    stall = Stall()
    stall.set_state(OccupiedMaintenanceState(stall))  # Moving to OccupiedMaintenanceState first
    with pytest.raises(Exception, match="Already under maintenance."):
        stall.report_issue()
    assert isinstance(stall.state, OccupiedMaintenanceState)

# Test invalid transition: FreeMaintenanceState -> report_issue should raise Exception
def test_free_maintenance_report_issue_invalid():
    stall = Stall()
    stall.set_state(FreeMaintenanceState(stall))  # Moving to FreeMaintenanceState first
    with pytest.raises(Exception, match="Already under maintenance."):
        stall.report_issue()
    assert isinstance(stall.state, FreeMaintenanceState)

# Test invalid transition: FreeState -> finish_maintenance should raise Exception
def test_free_finish_maintenance_invalid():
    stall = Stall()
    with pytest.raises(Exception, match="Already in a free state."):
        stall.finish_maintenance()
    assert isinstance(stall.state, FreeState)

# Test invalid transition: OccupiedState -> assign should raise Exception
def test_occupied_assign_invalid():
    stall = Stall()
    stall.set_state(OccupiedState(stall))
    with pytest.raises(Exception, match="Cannot assign while occupied."):
        stall.assign()
    assert isinstance(stall.state, OccupiedState)

# Test invalid transition: FreeMaintenanceState -> assign should raise Exception
def test_free_maintenance_assign_invalid():
    stall = Stall()
    stall.set_state(FreeMaintenanceState(stall))
    with pytest.raises(Exception, match="Cannot assign. Stall is under maintenance."):
        stall.assign()
    assert isinstance(stall.state, FreeMaintenanceState)



</tests>

<language>
python 
</language>

<output>
Return only the fully refactored code.
Do not include tests, explanations, comments, or any additional text.
</output>

Your code: