You are a senior software engineer with deep expertise in design patterns and code refactoring.
Your task is to refactor the provided code by applying the specified design pattern while ensuring all tests pass and the code’s original functionality remains intact.
You will receive a detailed task, the original code, the design pattern to apply, and the associated tests.

<task>
Apply the strategy design pattern based on the description provided.
Preserve the original behavior; all tests must pass after refactoring.
Do not rename any classes, functions, or modules in a way that would break existing import statements in the tests.
Follow existing code style and naming conventions where possible.
If applying the pattern exactly as described would break the tests or result in worse code design, adapt it thoughtfully to fit the context while preserving the spirit of the pattern.
</task>

<code>
class Vector:

    def __init__(self):
        self.__elements = []
        self.size = 0
    
    def add(self, element):
        self.__elements.append(element)
        self.size += 1
    def pop(self):
        if self.size == 0:
            raise IndexError("pop from empty vector")
        self.size -= 1
        return self.__elements.pop()
    
    
    def sort(self):
        #sort the elements using selection sort
        for i in range(self.size):
            min_index = i
            for j in range(i + 1, self.size):
                if self.__elements[j] < self.__elements[min_index]:
                    min_index = j
            self.__elements[i], self.__elements[min_index] = self.__elements[min_index], self.__elements[i]
    
    def get(self, index):
        if index < 0 or index >= self.size:
            raise IndexError("Index out of bounds")
        return self.__elements[index]
    
    def to_string(self):
        return str(self.__elements)


</code>

<designPatternName>
strategy
</designPatternName>

<designPatternDescription>
Intent
Define a family of algorithms, encapsulate each one, and make them interchangeable.
Strategy lets the algorithm vary independently fromclients that use it.
Motivation
Many algorithms exist for breaking a stream of text into lines.Hard-wiring all
such algorithms into the classes that require them isn't desirable for several
reasons:
· Clients that need line breaking get more complex if they include the
line breaking code. That makes clients bigger and harder to maintain,
especially if they support multiple line breaking algorithms.
· Different algorithms will be appropriate at different times. We don't want
to support multiple line breaking algorithms if we don't use thermally.
· It's difficult to add new algorithms and vary existing ones when line breaking
is an integral part of a client.
We can avoid these problems by defining classes that encapsulate different
line breaking algorithms. An algorithm that's encapsulated in this way is called
a strategy.
Suppose a Composition class is responsible for maintaining and updating the
line breaks of text displayed in a text viewer.Line breaking strategies aren't
implemented by the class Composition.Instead, they are implemented separately
by subclasses of the abstractCompositor class. Compositor subclasses implement
different strategies:
· SimpleCompositorimplements a simple strategy that determines linebreaks
one at time.
· TeXCompositorimplements the TeX algorithm for finding linebreaks. This
strategy tries to optimize linebreaks globally, that is, one paragraph at
time.
· ArrayCompositorimplements a strategy that selects breaks so that each row
has a fixed number of items. It's useful for breaking a collection of icons
into rows, for example.
A Composition maintains a reference to a Compositor object. Whenever a Composition
reformats its text, it forwards this responsibility to its Compositor object. The
client of Composition specifies which Compositor should be used by installing the
Compositor it desires into the Composition.
Structure
@startuml
title Strategy Pattern
' ==== Strategy Interface ====
interface Strategy {
    +execute(): void
}
' ==== Concrete Strategies ====
class ConcreteStrategyA implements Strategy {
    +execute(): void
}
class ConcreteStrategyB implements Strategy {
    +execute(): void
}
class ConcreteStrategyC implements Strategy {
    +execute(): void
}
' ==== Context ====
class Context {
    -strategy: Strategy
    +setStrategy(s: Strategy): void
    +performAction(): void
}
' ==== Relationships ====
Context --> Strategy : uses
@enduml
Participants
· Strategy (Compositor)
o declares an interface common to all supported algorithms. Context
uses this interface to call the algorithm defined by a
ConcreteStrategy.
· ConcreteStrategy (SimpleCompositor, TeXCompositor,ArrayCompositor)
o implements the algorithm using the Strategy interface.
· Context (Composition)
o is configured with a ConcreteStrategy object.
o maintains a reference to a Strategy object.
o may define an interface that lets Strategy access its data.
Collaborations
· Strategy and Context interact to implement the chosen algorithm. Context
may pass all data required by the algorithm to the strategy when the algorithm
is called. Alternatively, the context can pass itself as an argument to
Strategy operations. That lets the strategically back on the context as
required.
· A context forwards requests from its clients to its strategy. Clients usually
create and pass a ConcreteStrategy object to the context;thereafter,
clients interact with the context exclusively. There soften a family of
ConcreteStrategy classes for a client to choose from.
Implementation
Consider the following implementation issues:
1. Defining the Strategy and Context interfaces.The Strategy and Context
interfaces must give a ConcreteStrategy efficient access to any data it needs
from a context, and vice versa.
One approach is to have Context pass data in parameters to
Strategy operations—in other words, take the data to the strategy. This
keeps Strategy and Context decoupled. On the other hand, Context might pass
data the Strategy doesn't need.
Another technique has a context pass itself as an argument, and the strategy
requests data from the context explicitly.Alternatively, the strategy can
store a reference to its context,eliminating the need to pass anything at
all. Either way, the strategy can request exactly what it needs. But now
Context must define a more elaborate interface to its data, which couples
Strategy and Context more closely.
The needs of the particular algorithm and its data requirements
will determine the best technique.
2. Strategies as template parameters.In C++ templates can be used to configure
a class with a strategy.This technique is only applicable if (1) the Strategy
can be selected at compile-time, and (2) it does not have to be changed at
run-time.In this case, the class to be configured (e.g., Context) is defined
as a template class that has a Strategy class as parameter:
template <class AStrategy>
class Context {
void Operation() { theStrategy.DoAlgorithm(); }
// ...
private:
AStrategy theStrategy;
};
The class is then configured with a Strategy class when it's
instantiated:
class MyStrategy {
public:
void DoAlgorithm();
};
Context<MyStrategy> aContext;
With templates, there's no need to define an abstract class that defines
the interface to the Strategy. Using Strategy as atemplate parameter also
lets you bind a Strategy to its Context statically, which can increase
efficiency.
3. Making Strategy objects optional.The Context class may be simplified if
it's meaningful not Mohave a Strategy object. Context checks to see if it
has a Strategyobject before accessing it. If there is one, then Context
uses it normally. If there isn't a strategy, then Context carries out
default behavior. The benefit of this approach is that clients don't have
tidal with Strategy objects at all unless they don't like the default
behavior.
Sample Code
---
We'll give the high-level code for the Motivation example, which is based on the implementation of the `Composition` and `Compositor` classes in *InterViews* [LCI+92]. The `Composition` class maintains a collection of `Component` instances, which represent text and graphical elements in a document. A composition arranges component objects into lines using an instance of a `Compositor` subclass, which encapsulates a line-breaking strategy. Each component has an associated natural size, stretchability, and shrinkability. The stretchability defines how much the component can grow beyond its natural size, and shrinkability is how much it can shrink. The composition passes these values to a compositor, which uses them to determine the best location for line breaks.
### Composition Class:
```cpp
class Composition {
public:
    Composition(Compositor*);
    void Repair();
private:
    Compositor* _compositor;
    Component* _components;  // the list of components
    int _componentCount;     // the number of components
    int _lineWidth;          // the Composition's line width
    int* _lineBreaks;        // the position of line breaks in components
    int _lineCount;          // the number of lines
};
```
When a new layout is required, the composition asks its compositor to determine where to place line breaks. The composition passes the compositor three arrays that define natural sizes, stretchabilities, and shrinkabilities of the components. It also passes the number of components, how wide the line is, and an array that the compositor fills with the position of each line break. The compositor returns the number of calculated breaks.
The `Compositor` interface lets the composition pass the compositor all the information it needs. This is an example of "taking the data to the strategy":
### Compositor Interface:
```cpp
class Compositor {
public:
    virtual int Compose(
        Coord natural[], Coord stretch[], Coord shrink[],
        int componentCount, int lineWidth, int breaks[]
    ) = 0;
protected:
    Compositor();
};
```
Note that `Compositor` is an abstract class. Concrete subclasses define specific line-breaking strategies. The composition calls its compositor in its `Repair` operation. `Repair` first initializes arrays with the natural size, stretchability, and shrinkability of each component (the details of which we omit for brevity). Then it calls on the compositor to obtain the line breaks and finally lays out the components according to the breaks (also omitted):
### Repair Method:
```cpp
void Composition::Repair() {
    Coord* natural;
    Coord* stretchability;
    Coord* shrinkability;
    int componentCount;
    int* breaks;
    // prepare the arrays with the desired component sizes
    // ...
    // determine where the breaks are:
    int breakCount;
    breakCount = _compositor->Compose(
        natural, stretchability, shrinkability,
        componentCount, _lineWidth, breaks
    );
    // lay out components according to breaks
    // ...
}
```
Now let's look at the `Compositor` subclasses.
### SimpleCompositor Class:
```cpp
class SimpleCompositor : public Compositor {
public:
    SimpleCompositor();
    virtual int Compose(
        Coord natural[], Coord stretch[], Coord shrink[],
        int componentCount, int lineWidth, int breaks[]
    );
    // ...
};
```
`TeXCompositor` uses a more global strategy. It examines a paragraph at a time, taking into account the components' size and stretchability. It also tries to give an even "color" to the paragraph by minimizing the whitespace between components.
### TeXCompositor Class:
```cpp
class TeXCompositor : public Compositor {
public:
    TeXCompositor();
    virtual int Compose(
        Coord natural[], Coord stretch[], Coord shrink[],
        int componentCount, int lineWidth, int breaks[]
    );
    // ...
};
```
`ArrayCompositor` breaks the components into lines at regular intervals.
### ArrayCompositor Class:
```cpp
class ArrayCompositor : public Compositor {
public:
    ArrayCompositor(int interval);
    virtual int Compose(
        Coord natural[], Coord stretch[], Coord shrink[],
        int componentCount, int lineWidth, int breaks[]
    );
    // ...
};
```
These classes don't use all the information passed in `Compose`. `SimpleCompositor` ignores the stretchability of the components, taking only their natural widths into account. `TeXCompositor` uses all the information passed to it, whereas `ArrayCompositor` ignores everything.
To instantiate `Composition`, you pass it the compositor you want to use:
```cpp
Composition* quick = new Composition(new SimpleCompositor);
Composition* slick = new Composition(new TeXCompositor);
Composition* iconic = new Composition(new ArrayCompositor(100));
```
The `Compositor`'s interface is carefully designed to support all layout algorithms that subclasses might implement. You don't want to have to change this interface with every new subclass, because that will require changing existing subclasses. In general, the Strategy and Context interfaces determine how well the pattern achieves its intent.
---
</description>
</designPatternDescription>

<tests>
import pytest
from refactored.Vector import *

def test_add():
    """Test adding elements increases size and stores values correctly."""
    vec = Vector()
    vec.add(10)
    assert vec.size == 1
    assert vec.get(0) == 10
    
    vec.add(20)
    assert vec.size == 2
    assert vec.get(1) == 20

def test_pop():
    """Test popping elements returns the correct value and decreases size."""
    vec = Vector()
    vec.add(5)
    vec.add(15)
    
    assert vec.pop() == 15  # Last-in, first-out
    assert vec.size == 1
    assert vec.pop() == 5
    assert vec.size == 0
    
    with pytest.raises(IndexError):
        vec.pop()  # Popping from empty vector should raise IndexError

def test_sort():
    """Test sorting functionality using various cases."""
    vec = Vector()
    vec.add(3)
    vec.add(1)
    vec.add(2)
    
    vec.sort()
    assert vec.get(0) == 1
    assert vec.get(1) == 2
    assert vec.get(2) == 3
    
    vec = Vector()  # Test empty vector sort
    vec.sort()  # Should not raise an error
    assert vec.to_string() == "[]"
    
    vec.add(7)  # Test single element sort
    vec.sort()
    assert vec.get(0) == 7

def test_get():
    """Test get method for valid and invalid indices."""
    vec = Vector()
    vec.add(100)
    assert vec.get(0) == 100
    
    with pytest.raises(IndexError):
        vec.get(1)  # Out of bounds
    
    with pytest.raises(IndexError):
        vec.get(-1)  # Negative index out of bounds

def test_to_string():
    """Test string representation of the vector using to_string method."""
    vec = Vector()
    assert vec.to_string() == "[]"
    
    vec.add(1)
    vec.add(2)
    assert vec.to_string() == "[1, 2]"

def test_set_sort_strategy():
    """Test setting a different sorting strategy."""
    vec = Vector()
    vec.set_sort_strategy(SelectionSort())  # Ensure it doesn't break the class
    vec.add(4)
    vec.add(2)
    vec.add(3)
    vec.sort()
    assert vec.get(0) == 2
    assert vec.get(1) == 3
    assert vec.get(2) == 4
</tests>

<language>
python 
</language>

<output>
Return only the fully refactored code.
Do not include tests, explanations, comments, or any additional text.
</output>

Your code: