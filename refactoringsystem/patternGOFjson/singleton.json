{
  "Intent": "Ensure a class only has one instance, and provide a global point of access to\nit.",
  "Motivation": "It's important for some classes to have exactly one instance. Although there can\nbe many printers in a system, there should be only one printer spooler. There\nshould be only one file system and one window manager. A digital filter will have\none A/D converter. An accounting system will be dedicated to serving one company.\nHow do we ensure that a class has only one instance and that the instance is easily\naccessible? A global variable makes an object accessible, but it doesn't keep\nyou from instantiating multiple objects.\nA better solution is to make the class itself responsible for keeping track of\nits sole instance. The class can ensure that no other instance can be created\n(by intercepting requests to create new objects), and it can provide a way to\naccess the instance. This is the Singleton pattern.",
  "Structure": "@startuml\ntitle Singleton Pattern\nclass Singleton {\n    -instance: Singleton\n    -Singleton()\n    +getInstance(): Singleton\n    +operation(): void\n}\n' Highlight static property\nSingleton : <<static>> instance\nSingleton : <<static>> getInstance()\n' Notes for explanation\nnote right of Singleton::getInstance\n    Returns the same instance every time\n    Ensures only one object exists\nend note\n@enduml",
  "Participants": "\u00b7 Singleton\no defines an Instance operation that lets clients access its unique\ninstance. Instance is a class operation (that is, a class method\nin Smalltalk and a static member function in C++).\no may be responsible for creating its own unique instance.",
  "Collaborations": "\u00b7 Clients access a Singleton instance solely through Singleton's Instance\noperation.",
  "Implementation": "Here are implementation issues to consider when using the Singleton pattern:\n1. Ensuring a unique instance. The Singleton pattern makes the sole instance\na normal instance of a class, but that class is written so that only one\ninstance can ever be created. A common way to do this is to hide the operation\nthat creates the instance behind a class operation (that is, either a static\nmember function or a class method) that guarantees only one instance is\ncreated. This operation has access to the variable that holds the unique\ninstance, and it ensures the variable is initialized with the unique\ninstance before returning its value. This approach ensures that a singleton\nis created and initialized before its first use.\nYou can define the class operation in C++ with a static member function\nInstance of the Singleton class. Singleton also defines a static member\nvariable _instance that contains a pointer to its unique instance.\nThe Singleton class is declared as\n class Singleton {\n public:\n static Singleton* Instance();\n protected:\n Singleton();\n private:\n static Singleton* _instance;\n };\nThe corresponding implementation is\n Singleton* Singleton::_instance = 0;\n Singleton* Singleton::Instance () {\n if (_instance == 0) {\n _instance = new Singleton;\n }\n return _instance;\n }\nClients access the singleton exclusively through the Instance member\nfunction. The variable _instance is initialized to 0, and the static member\nfunction Instance returns its value, initializing it with the unique\ninstance if it is 0. Instance uses lazy initialization; the value it returns\nisn't created and stored until it's first accessed.\nNotice that the constructor is protected. A client that tries to instantiate\nSingleton directly will get an error at compile-time. This ensures that\nonly one instance can ever get created.\nMoreover, since the _instance is a pointer to a Singleton object, the\nInstance member function can assign a pointer to a subclass of Singleton\nto this variable. We'll give an example of this in the Sample Code.\nThere's another thing to note about the C++ implementation. It isn't enough\nto define the singleton as a global or static object and then rely on\nautomatic initialization. There are three reasons for this:\n1. We can't guarantee that only one instance of a static object will\never be declared.\n2. We might not have enough information to instantiate every singleton\nat static initialization time. A singleton might require values that\nare computed later in the program's execution.\n3. C++ doesn't define the order in which constructors for global objects\nare called across translation units [ES90]. This means that no\ndependencies can exist between singletons; if any do, then errors\nare inevitable.\nAn added (albeit small) liability of the global/static object approach is\nthat it forces all singletons to be created whether they are used or not.\nUsing a static member function avoids all of these problems.\nIn Smalltalk, the function that returns the unique instance is implemented\nas a class method on the Singleton class. To ensure that only one instance\nis created, override the new operation. The resulting Singleton class might\nhave the following two class methods, where SoleInstance is a class variable\nthat is not used anywhere else:\n new\n self error: 'cannot create new object'\n default\n SoleInstance isNil ifTrue: [SoleInstance := super new].\n ^ SoleInstance\n2. Subclassing the Singleton class. The main issue is not so much defining\nthe subclass but installing its unique instance so that clients will be\nable to use it. In essence, the variable that refers to the singleton\ninstance must get initialized with an instance of the subclass. The simplest\ntechnique is to determine which singleton you want to use in the Singleton's\nInstance operation. An example in the Sample Code shows how to implement\nthis technique with environment variables.\nAnother way to choose the subclass of Singleton is to take the implementation\nof Instance out of the parent class (e.g., MazeFactory) and put it in the\nsubclass. That lets a C++ programmer decide the class of singleton at\nlink-time (e.g., by linking in an object file containing a different\nimplementation) but keeps it hidden from the clients of the singleton.\nThe link approach fixes the choice of singleton class at link-time, which\nmakes it hard to choose the singleton class at run-time. Using conditional\nstatements to determine the subclass is more flexible, but it hard-wires\nthe set of possible Singleton classes. Neither approach is flexible enough\nin all cases.\nA more flexible approach uses a registry of singletons. Instead of having\nInstance define the set of possible Singleton classes, the Singleton classes\ncan register their singleton instance by name in a well-known registry.\nThe registry maps between string names and singletons. When Instance needs\na singleton, it consults the registry, asking for the singleton by name.\nThe registry looks up the corresponding singleton (if it exists) and returns\nit. This approach frees Instance from knowing all possible Singleton classes\nor instances. All it requires is a common interface for all Singleton classes\nthat includes operations for the registry:\n class Singleton {\n public:\n static void Register(const char* name, Singleton*);\n static Singleton* Instance();\n protected:\n static Singleton* Lookup(const char* name);\n private:\n static Singleton* _instance;\n static List<NameSingletonPair>* _registry;\n };\nRegister registers the Singleton instance under the given name. To keep\nthe registry simple, we'll have it store a list of NameSingletonPair objects.\nEach NameSingletonPair maps a name to a singleton. The Lookup operation\nfinds a singleton given its name. We'll assume that an environment variable\nspecifies the name of the singleton desired.\n Singleton* Singleton::Instance () {\n if (_instance == 0) {\n const char* singletonName = getenv(\"SINGLETON\");\n // user or environment supplies this at startup\n _instance = Lookup(singletonName);\n // Lookup returns 0 if there's no such singleton\n }\n return _instance;\n }\nWhere do Singleton classes register themselves? One possibility is in their\nconstructor. For example, a MySingleton subclass could do the following:\n MySingleton::MySingleton() {\n // ...\n Singleton::Register(\"MySingleton\", this);\n }\nOf course, the constructor won't get called unless someone instantiates\nthe class, which echoes the problem the Singleton pattern is trying to solve!\nWe can get around this problem in C++ by defining a static instance of\nMySingleton. For example, we can define\n static MySingleton theSingleton;\nin the file that contains MySingleton's implementation.\nNo longer is the Singleton class responsible for creating the singleton.\nInstead, its primary responsibility is to make the singleton object of\nchoice accessible in the system. The static object approach still has a\npotential drawback\u2014namely that instances of all possible Singleton\nsubclasses must be created, or else they won't get registered.",
  "Sample Code": "---\nSuppose we define a `MazeFactory` class for building mazes as described on page 92. `MazeFactory` defines an interface for building different parts of a maze. Subclasses can redefine the operations to return instances of specialized product classes, like `BombedWall` objects instead of plain `Wall` objects.\nWhat's relevant here is that the Maze application needs only one instance of a maze factory, and that instance should be available to code that builds any part of the maze. This is where the Singleton pattern comes in. By making the `MazeFactory` a singleton, we make the maze object globally accessible without resorting to global variables.\nFor simplicity, let's assume we'll never subclass `MazeFactory`. (We'll consider the alternative in a moment.) We make it a Singleton class in C++ by adding a static `Instance` operation and a static `_instance` member to hold the one and only instance. We must also protect the constructor to prevent accidental instantiation, which might lead to more than one instance.\n```cpp\nclass MazeFactory {\n public:\n     static MazeFactory* Instance();\n     // existing interface goes here\n protected:\n     MazeFactory();\n private:\n     static MazeFactory* _instance;\n};\n```\nThe corresponding implementation is:\n```cpp\nMazeFactory* MazeFactory::_instance = 0;\nMazeFactory* MazeFactory::Instance() {\n    if (_instance == 0) {\n        _instance = new MazeFactory;\n    }\n    return _instance;\n}\n```\nNow let's consider what happens when there are subclasses of `MazeFactory`, and the application must decide which one to use. We'll select the kind of maze through an environment variable and add code that instantiates the proper `MazeFactory` subclass based on the environment variable's value. The `Instance` operation is a good place to put this code, because it already instantiates `MazeFactory`:\n```cpp\nMazeFactory* MazeFactory::Instance() {\n    if (_instance == 0) {\n        const char* mazeStyle = getenv(\"MAZESTYLE\");\n        if (strcmp(mazeStyle, \"bombed\") == 0) {\n            _instance = new BombedMazeFactory;\n        } else if (strcmp(mazeStyle, \"enchanted\") == 0) {\n            _instance = new EnchantedMazeFactory;\n            // ... other possible subclasses\n        } else { // default\n            _instance = new MazeFactory;\n        }\n    }\n    return _instance;\n}\n```\nNote that `Instance` must be modified whenever you define a new subclass of `MazeFactory`. That might not be a problem in this application, but it might be for abstract factories defined in a framework.\nA possible solution would be to use the registry approach described in the Implementation section. Dynamic linking could be useful here as well\u2014it would keep the application from having to load all the subclasses that are not used.\n---"
}