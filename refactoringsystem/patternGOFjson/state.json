{
  "Intent": "Allow an object to alter its behavior when its internal state changes.The object\nwill appear to change its class.",
  "Motivation": "Consider a class TCPConnection that represents a network connection.A\nTCPConnection object can be in one of several different states:Established,\nListening, Closed. When a TCPConnection object receivesrequests from other objects,\nit responds differently depending on itscurrent state. For example, the effect\nof an Open request depends onwhether the connection is in its Closed state or\nits Establishedstate. The State pattern describes how TCPConnection can\nexhibitdifferent behavior in each state.\nThe key idea in this pattern is to introduce an abstract class calledTCPState\nto represent the states of the network connection. TheTCPState class declares\nan interface common to all classes thatrepresent different operational states.\nSubclasses of TCPStateimplement state-specific behavior. For example, the\nclassesTCPEstablished and TCPClosed implement behavior particular to\ntheEstablished and Closed states of TCPConnection.\nThe class TCPConnection maintains a state object (an instance of asubclass of\nTCPState) that represents the current state of the TCPconnection. The class\nTCPConnection delegates all state-specificrequests to this state object.\nTCPConnection uses its TCPStatesubclass instance to perform operations particular\nto the state of theconnection.\nWhenever the connection changes state, the TCPConnection objectchanges the state\nobject it uses. When the connection goes fromestablished to closed, for example,\nTCPConnection will replace itsTCPEstablished instance with a TCPClosed instance.",
  "Structure": "@startuml\ntitle State Pattern\n' Context\nclass Context {\n    -state: State\n    +setState(s: State): void\n    +request(): void\n}\n' State Interface\ninterface State {\n    +handle(context: Context): void\n}\n' Concrete States\nclass ConcreteStateA implements State {\n    +handle(context: Context): void\n}\nclass ConcreteStateB implements State {\n    +handle(context: Context): void\n}\n' Relationships\nContext --> State : \"has a\"\n@enduml",
  "Participants": "\u00b7 Context (TCPConnection)\no defines the interface of interest to clients.\no maintains an instance of a ConcreteState subclass that defines\nthecurrent state.\n\u00b7 State (TCPState)\no defines an interface for encapsulating the behavior associated with\naparticular state of the Context.\n\u00b7 ConcreteState subclasses (TCPEstablished, TCPListen, TCPClosed)\no each subclass implements a behavior associated with a state ofthe\nContext.",
  "Collaborations": "\u00b7 Context delegates state-specific requests to the current\nConcreteStateobject.\n\u00b7 A context may pass itself as an argument to the State objecthandling the\nrequest. This lets the State object accessthe context if necessary.\n\u00b7 Context is the primary interface for clients. Clients can configure acontext\nwith State objects. Once a context is configured, its clients don't have\nto deal with the State objects directly.\n\u00b7 Either Context or the ConcreteState subclasses can decide which\nstatesucceeds another and under what circumstances.",
  "Implementation": "The State pattern raises a variety of implementation issues:\n1. Who defines the state transitions?The State pattern does not specify which\nparticipant defines thecriteria for state transitions. If the criteria are\nfixed, then theycan be implemented entirely in the Context. It is generally\nmoreflexible and appropriate, however, to let the State\nsubclassesthemselves specify their successor state and when to make\nthetransition. This requires adding an interface to the Context thatlets\nState objects set the Context's current state explicitly.\nDecentralizing the transition logic in this way makes it easy tomodify or\nextend the logic by defining new State subclasses. Adisadvantage of\ndecentralization is that one State subclass will haveknowledge of at least\none other, which introduces implementationdependencies between\nsubclasses.\n2. A table-based alternative.In C++ Programming Style [Car92],\nCargilldescribes another way to impose structure on state-driven code:\nHeuses tables to map inputs to state transitions. For each state, atable\nmaps every possible input to a succeeding state. In effect,this approach\nconverts conditional code (and virtual functions, in thecase of the State\npattern) into a table look-up.\nThe main advantage of tables is their regularity: You can change\nthetransition criteria by modifying data instead of changing programcode.\nThere are some disadvantages, however:\no A table look-up is often less efficient than a (virtual)function\ncall.\no Putting transition logic into a uniform, tabular format makes\nthetransition criteria less explicit and therefore harder to\nunderstand.\no It's usually difficult to add actions to accompany the\nstatetransitions. The table-driven approach captures the states and\ntheirtransitions, but it must be augmented to perform arbitrary\ncomputationon each transition.\nThe key difference between table-driven state machines and the Statepattern\ncan be summed up like this: The State pattern modelsstate-specific behavior,\nwhereas the table-driven approach focuses ondefining state transitions.\n3. Creating and destroying State objects.A common implementation trade-off\nworth considering is whether(1) to create State objects only when they are\nneeded and destroy themthereafter versus (2) creating them ahead of time\nand neverdestroying them.\nThe first choice is preferable when the states that will be enteredaren't\nknown at run-time, and contexts change stateinfrequently. This approach\navoids creating objects that won't beused, which is important if the State\nobjects store a lot ofinformation. The second approach is better when state\nchanges occurrapidly, in which case you want to avoid destroying states,\nbecausethey may be needed again shortly. Instantiation costs are paid\nonceup-front, and there are no destruction costs at all. This approachmight\nbe inconvenient, though, because the Context must keepreferences to all\nstates that might be entered.\n4. Using dynamic inheritance.Changing the behavior for a particular request\ncould be accomplishedby changing the object's class at run-time, but this\nis not possiblein most object-oriented programming languages. Exceptions\nincludeSelf [US87] and other delegation-based languages thatprovide such\na mechanism and hence support the State pattern directly.Objects in Self\ncan delegate operations to other objects to achieve aform of dynamic\ninheritance. Changing the delegation target atrun-time effectively changes\nthe inheritance structure. Thismechanism lets objects change their\nbehavior and amounts to changingtheir class.",
  "Sample Code": "---\nThe following example gives the C++ code for the TCP connection example described in the *Motivation* section. This example is a simplified version of the TCP protocol; it doesn't describe the complete protocol or all the states of TCP connections.\n---\nFirst, we define the class `TCPConnection`, which provides an interface for transmitting data and handles requests to change state.\n```cpp\nclass TCPOctetStream;\nclass TCPState;\nclass TCPConnection {\npublic:\n    TCPConnection();\n    void ActiveOpen();\n    void PassiveOpen();\n    void Close();\n    void Send();\n    void Acknowledge();\n    void Synchronize();\n    void ProcessOctet(TCPOctetStream*);\nprivate:\n    friend class TCPState;\n    void ChangeState(TCPState*);\nprivate:\n    TCPState* _state;\n};\n```\n`TCPConnection` keeps an instance of the `TCPState` class in the `_state` member variable. The class `TCPState` duplicates the state-changing interface of `TCPConnection`. Each `TCPState` operation takes a `TCPConnection` instance as a parameter, letting `TCPState` access data from `TCPConnection` and change the connection's state.\n```cpp\nclass TCPState {\npublic:\n    virtual void Transmit(TCPConnection*, TCPOctetStream*);\n    virtual void ActiveOpen(TCPConnection*);\n    virtual void PassiveOpen(TCPConnection*);\n    virtual void Close(TCPConnection*);\n    virtual void Synchronize(TCPConnection*);\n    virtual void Acknowledge(TCPConnection*);\n    virtual void Send(TCPConnection*);\nprotected:\n    void ChangeState(TCPConnection*, TCPState*);\n};\n```\n`TCPConnection` delegates all state-specific requests to its `TCPState` instance `_state`. `TCPConnection` also provides an operation for changing this variable to a new `TCPState`. The constructor for `TCPConnection` initializes the object to the `TCPClosed` state (defined later).\n```cpp\nTCPConnection::TCPConnection () {\n    _state = TCPClosed::Instance();\n}\nvoid TCPConnection::ChangeState (TCPState* s) {\n    _state = s;\n}\nvoid TCPConnection::ActiveOpen () {\n    _state->ActiveOpen(this);\n}\nvoid TCPConnection::PassiveOpen () {\n    _state->PassiveOpen(this);\n}\nvoid TCPConnection::Close () {\n    _state->Close(this);\n}\nvoid TCPConnection::Acknowledge () {\n    _state->Acknowledge(this);\n}\nvoid TCPConnection::Synchronize () {\n    _state->Synchronize(this);\n}\n```\n`TCPState` implements default behavior for all requests delegated to it. It can also change the state of a `TCPConnection` with the `ChangeState` operation. `TCPState` is declared a friend of `TCPConnection` to give it privileged access to this operation.\n```cpp\nvoid TCPState::Transmit (TCPConnection*, TCPOctetStream*) { }\nvoid TCPState::ActiveOpen (TCPConnection*) { }\nvoid TCPState::PassiveOpen (TCPConnection*) { }\nvoid TCPState::Close (TCPConnection*) { }\nvoid TCPState::Synchronize (TCPConnection*) { }\nvoid TCPState::ChangeState (TCPConnection* t, TCPState* s) {\n    t->ChangeState(s);\n}\n```\nSubclasses of `TCPState` implement state-specific behavior. A TCP connection can be in many states: Established, Listening, Closed, etc., and there's a subclass of `TCPState` for each state. We'll discuss three subclasses in detail: `TCPEstablished`, `TCPListen`, and `TCPClosed`.\n```cpp\nclass TCPEstablished : public TCPState {\npublic:\n    static TCPState* Instance();\n    virtual void Transmit(TCPConnection*, TCPOctetStream*);\n    virtual void Close(TCPConnection*);\n};\nclass TCPListen : public TCPState {\npublic:\n    static TCPState* Instance();\n    virtual void Send(TCPConnection*);\n    // ...\n};\nclass TCPClosed : public TCPState {\npublic:\n    static TCPState* Instance();\n    virtual void ActiveOpen(TCPConnection*);\n    virtual void PassiveOpen(TCPConnection*);\n    // ...\n};\n```\n`TCPState` subclasses maintain no local state, so they can be shared, and only one instance of each is required. The unique instance of each `TCPState` subclass is obtained by the static `Instance` operation.\nEach `TCPState` subclass implements state-specific behavior for valid requests in the state:\n```cpp\nvoid TCPClosed::ActiveOpen (TCPConnection* t) {\n    // send SYN, receive SYN, ACK, etc.\n    ChangeState(t, TCPEstablished::Instance());\n}\nvoid TCPClosed::PassiveOpen (TCPConnection* t) {\n    ChangeState(t, TCPListen::Instance());\n}\nvoid TCPEstablished::Close (TCPConnection* t) {\n    // send FIN, receive ACK of FIN\n    ChangeState(t, TCPListen::Instance());\n}\nvoid TCPEstablished::Transmit (TCPConnection* t, TCPOctetStream* o) {\n    t->ProcessOctet(o);\n}\nvoid TCPListen::Send (TCPConnection* t) {\n    // send SYN, receive SYN, ACK, etc.\n    ChangeState(t, TCPEstablished::Instance());\n}\n```\nAfter performing state-specific work, these operations call the `ChangeState` operation to change the state of the `TCPConnection`. `TCPConnection` itself doesn't know a thing about the TCP connection protocol; it's the `TCPState` subclasses that define each state transition and action in TCP.\n---"
}