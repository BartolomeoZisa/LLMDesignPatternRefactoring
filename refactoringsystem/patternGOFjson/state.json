{
  "Intent": "Allow an object to alter its behavior when its internal state changes.The object\nwill appear to change its class.",
  "Motivation": "Consider a class TCPConnection that represents a network connection.A\nTCPConnection object can be in one of several different states:Established,\nListening, Closed. When a TCPConnection object receivesrequests from other objects,\nit responds differently depending on itscurrent state. For example, the effect\nof an Open request depends onwhether the connection is in its Closed state or\nits Establishedstate. The State pattern describes how TCPConnection can\nexhibitdifferent behavior in each state.\nThe key idea in this pattern is to introduce an abstract class calledTCPState\nto represent the states of the network connection. TheTCPState class declares\nan interface common to all classes thatrepresent different operational states.\nSubclasses of TCPStateimplement state-specific behavior. For example, the\nclassesTCPEstablished and TCPClosed implement behavior particular to\ntheEstablished and Closed states of TCPConnection.\nThe class TCPConnection maintains a state object (an instance of asubclass of\nTCPState) that represents the current state of the TCPconnection. The class\nTCPConnection delegates all state-specificrequests to this state object.\nTCPConnection uses its TCPStatesubclass instance to perform operations particular\nto the state of theconnection.\nWhenever the connection changes state, the TCPConnection objectchanges the state\nobject it uses. When the connection goes fromestablished to closed, for example,\nTCPConnection will replace itsTCPEstablished instance with a TCPClosed instance.",
  "Structure": "@startuml\ntitle State Pattern\n' Context\nclass Context {\n    -state: State\n    +setState(s: State): void\n    +request(): void\n}\n' State Interface\ninterface State {\n    +handle(context: Context): void\n}\n' Concrete States\nclass ConcreteStateA implements State {\n    +handle(context: Context): void\n}\nclass ConcreteStateB implements State {\n    +handle(context: Context): void\n}\n' Relationships\nContext --> State : \"has a\"\n@enduml",
  "Participants": "\u00b7 Context (TCPConnection)\no defines the interface of interest to clients.\no maintains an instance of a ConcreteState subclass that defines\nthecurrent state.\n\u00b7 State (TCPState)\no defines an interface for encapsulating the behavior associated with\naparticular state of the Context.\n\u00b7 ConcreteState subclasses (TCPEstablished, TCPListen, TCPClosed)\no each subclass implements a behavior associated with a state ofthe\nContext.",
  "Collaborations": "\u00b7 Context delegates state-specific requests to the current\nConcreteStateobject.\n\u00b7 A context may pass itself as an argument to the State objecthandling the\nrequest. This lets the State object accessthe context if necessary.\n\u00b7 Context is the primary interface for clients. Clients can configure acontext\nwith State objects. Once a context is configured, its clients don't have\nto deal with the State objects directly.\n\u00b7 Either Context or the ConcreteState subclasses can decide which\nstatesucceeds another and under what circumstances.",
  "Implementation": "The State pattern raises a variety of implementation issues:\n1. Who defines the state transitions?The State pattern does not specify which\nparticipant defines thecriteria for state transitions. If the criteria are\nfixed, then theycan be implemented entirely in the Context. It is generally\nmoreflexible and appropriate, however, to let the State\nsubclassesthemselves specify their successor state and when to make\nthetransition. This requires adding an interface to the Context thatlets\nState objects set the Context's current state explicitly.\nDecentralizing the transition logic in this way makes it easy tomodify or\nextend the logic by defining new State subclasses. Adisadvantage of\ndecentralization is that one State subclass will haveknowledge of at least\none other, which introduces implementationdependencies between\nsubclasses.\n2. A table-based alternative.In C++ Programming Style [Car92],\nCargilldescribes another way to impose structure on state-driven code:\nHeuses tables to map inputs to state transitions. For each state, atable\nmaps every possible input to a succeeding state. In effect,this approach\nconverts conditional code (and virtual functions, in thecase of the State\npattern) into a table look-up.\nThe main advantage of tables is their regularity: You can change\nthetransition criteria by modifying data instead of changing programcode.\nThere are some disadvantages, however:\no A table look-up is often less efficient than a (virtual)function\ncall.\no Putting transition logic into a uniform, tabular format makes\nthetransition criteria less explicit and therefore harder to\nunderstand.\no It's usually difficult to add actions to accompany the\nstatetransitions. The table-driven approach captures the states and\ntheirtransitions, but it must be augmented to perform arbitrary\ncomputationon each transition.\nThe key difference between table-driven state machines and the Statepattern\ncan be summed up like this: The State pattern modelsstate-specific behavior,\nwhereas the table-driven approach focuses ondefining state transitions.\n3. Creating and destroying State objects.A common implementation trade-off\nworth considering is whether(1) to create State objects only when they are\nneeded and destroy themthereafter versus (2) creating them ahead of time\nand neverdestroying them.\nThe first choice is preferable when the states that will be enteredaren't\nknown at run-time, and contexts change stateinfrequently. This approach\navoids creating objects that won't beused, which is important if the State\nobjects store a lot ofinformation. The second approach is better when state\nchanges occurrapidly, in which case you want to avoid destroying states,\nbecausethey may be needed again shortly. Instantiation costs are paid\nonceup-front, and there are no destruction costs at all. This approachmight\nbe inconvenient, though, because the Context must keepreferences to all\nstates that might be entered.\n4. Using dynamic inheritance.Changing the behavior for a particular request\ncould be accomplishedby changing the object's class at run-time, but this\nis not possiblein most object-oriented programming languages. Exceptions\nincludeSelf [US87] and other delegation-based languages thatprovide such\na mechanism and hence support the State pattern directly.Objects in Self\ncan delegate operations to other objects to achieve aform of dynamic\ninheritance. Changing the delegation target atrun-time effectively changes\nthe inheritance structure. Thismechanism lets objects change their\nbehavior and amounts to changingtheir class.",
  "Sample Code": "The following example gives the C++ code for the TCP connectionexample described\nin the Motivation section. This example is asimplified version of the TCP protocol;\nit doesn't describe thecomplete protocol or all the states of TCPconnections.\nFirst, we define the class TCPConnection, which provides aninterface for\ntransmitting data and handles requests to change state.\nclass TCPOctetStream;\nclass TCPState;\nclass TCPConnection {\npublic:\nTCPConnection();\nvoid ActiveOpen();\nvoid PassiveOpen();\nvoid Close();\nvoid Send();\nvoid Acknowledge();\nvoid Synchronize();\nvoid ProcessOctet(TCPOctetStream*);\nprivate:\nfriend class TCPState;\nvoid ChangeState(TCPState*);\nprivate:\nTCPState* _state;\n};\nTCPConnection keeps an instance of the TCPStateclass in the _state member variable.\nThe classTCPState duplicates the state-changing interface ofTCPConnection. Each\nTCPState operation takes aTCPConnection instance as a parameter, lettingTCPState\naccess data from TCPConnection andchange the connection's state.\nclass TCPState {\npublic:\nvirtual void Transmit(TCPConnection*, TCPOctetStream*);\nvirtual void ActiveOpen(TCPConnection*);\nvirtual void PassiveOpen(TCPConnection*);\nvirtual void Close(TCPConnection*);\nvirtual void Synchronize(TCPConnection*);\nvirtual void Acknowledge(TCPConnection*);\nvirtual void Send(TCPConnection*);\nprotected:\nvoid ChangeState(TCPConnection*, TCPState*);\n};\nTCPConnection delegates all state-specific requests to itsTCPState instance\n_state.TCPConnection also provides an operation for changing thisvariable to a\nnew TCPState. The constructor forTCPConnection initializes the object to\ntheTCPClosed state (defined later).\nTCPConnection::TCPConnection () {\n_state = TCPClosed::Instance();\n}\nvoid TCPConnection::ChangeState (TCPState* s) {\n_state = s;\n}\nvoid TCPConnection::ActiveOpen () {\n_state->ActiveOpen(this);\n}\nvoid TCPConnection::PassiveOpen () {\n_state->PassiveOpen(this);\n}\nvoid TCPConnection::Close () {\n_state->Close(this);\n}\nvoid TCPConnection::Acknowledge () {\n_state->Acknowledge(this);\n}\nvoid TCPConnection::Synchronize () {\n_state->Synchronize(this);\n}\nTCPState implements default behavior for all requestsdelegated to it. It can also\nchange the state of aTCPConnection with the ChangeState operation.TCPState is\ndeclared a friend of TCPConnection togive it privileged access to this operation.\nvoid TCPState::Transmit (TCPConnection*, TCPOctetStream*) { }\nvoid TCPState::ActiveOpen (TCPConnection*) { }\nvoid TCPState::PassiveOpen (TCPConnection*) { }\nvoid TCPState::Close (TCPConnection*) { }\nvoid TCPState::Synchronize (TCPConnection*) { }\nvoid TCPState::ChangeState (TCPConnection* t, TCPState* s) {\nt->ChangeState(s);\n}\nSubclasses of TCPState implement state-specific behavior. ATCP connection can\nbe in many states: Established, Listening, Closed,etc., and there's a subclass\nof TCPState for each state.We'll discuss three subclasses in detail:\nTCPEstablished,TCPListen, and TCPClosed.\nclass TCPEstablished : public TCPState {\npublic:\nstatic TCPState* Instance();\nvirtual void Transmit(TCPConnection*, TCPOctetStream*);\nvirtual void Close(TCPConnection*);\n};\nclass TCPListen : public TCPState {\npublic:\nstatic TCPState* Instance();\nvirtual void Send(TCPConnection*);\n// ...\n};\nclass TCPClosed : public TCPState {\npublic:\nstatic TCPState* Instance();\nvirtual void ActiveOpen(TCPConnection*);\nvirtual void PassiveOpen(TCPConnection*);\n// ...\n};\nTCPState subclasses maintain no local state, sothey can be shared, and only one\ninstance of each is required. Theunique instance of each TCPState subclass is\nobtained by thestatic Instanceoperation.\nEach TCPState subclass implements state-specific behaviorfor valid requests in\nthe state:\nvoid TCPClosed::ActiveOpen (TCPConnection* t) {\n// send SYN, receive SYN, ACK, etc.\nChangeState(t, TCPEstablished::Instance());\n}\nvoid TCPClosed::PassiveOpen (TCPConnection* t) {\nChangeState(t, TCPListen::Instance());\n}\nvoid TCPEstablished::Close (TCPConnection* t) {\n// send FIN, receive ACK of FIN\nChangeState(t, TCPListen::Instance());\n}\nvoid TCPEstablished::Transmit ( TCPConnection* t, TCPOctetStream* o ) {\nt->ProcessOctet(o);\n}\nvoid TCPListen::Send (TCPConnection* t) {\n// send SYN, receive SYN, ACK, etc.\nChangeState(t, TCPEstablished::Instance());\n}\nAfter performing state-specific work, these operations call theChangeState\noperation to change the state ofthe TCPConnection. TCPConnection itself\ndoesn'tknow a thing about the TCP connection protocol; it's theTCPState subclasses\nthat define each state transitionand action in TCP."
}