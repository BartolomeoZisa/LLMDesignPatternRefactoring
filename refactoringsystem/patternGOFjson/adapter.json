{
  "Intent": "Convert the interface of a class into another interface clients expect. Adapter\nlets classes work together that couldn't otherwise because of incompatible\ninterfaces.",
  "Structure": "A class adapter uses multiple inheritance to adapt one interface to another: \n@startuml\ninterface Target {\n  +request(): void\n}\ninterface Adaptee {\n  +specificRequest(): void\n}\nclass Adapter {\n  +request(): void\n}\nTarget <|.. Adapter\nAdaptee <|.. Adapter\nAdapter : +request() {\n  // The Adapter class implements the Target's request() method\n  // by calling the Adaptee's specificRequest() method\n}\n@enduml\nAn object adapter relies on object composition: \n@startuml\ninterface Target {\n  +request(): void\n}\ninterface Adaptee {\n  +specificRequest(): void\n}\nclass Adapter {\n  -adaptee: Adaptee\n  +request(): void\n}\nTarget <|.. Adapter\nAdaptee o-- Adapter\nAdapter : +request() {\n  // The Adapter class delegates the request() method to the adaptee's specificRequest() method\n}\n@enduml\nParticipants \n\u00b7 Target (Shape)\no defines the domain-specific interface that Client uses.\n\u00b7 Client (DrawingEditor)\no collaborates with objects conforming to the Target interface.\n\u00b7 Adaptee (TextView)\no defines an existing interface that needs adapting.\n\u00b7 Adapter (TextShape)\no adapts the interface of Adaptee to the Target interface.",
  "Collaborations": "\u00b7 Clients call operations on an Adapter instance. In turn, the adapter calls\nAdaptee operations that carry out the request.",
  "Implementation": "Although the implementation of Adapter is usually straightforward, here are some\nissues to keep in mind:\n1. Implementing class adapters in C++. In a C++ implementation of a class\nadapter, Adapter would inherit publicly from Target and privately from\nAdaptee. Thus Adapter would be a subtype of Target but not of Adaptee.\n2. Pluggable adapters. Let's look at three ways to implement pluggable adapters\nfor the TreeDisplay widget described earlier, which can lay out and display\na hierarchical structure automatically.\nThe first step, which is common to all three of the implementations discussed\nhere, is to find a \"narrow\" interface for Adaptee, that is, the smallest\nsubset of operations that lets us do the adaptation. A narrow interface\nconsisting of only a couple of operations is easier to adapt than an\ninterface with dozens of operations. For TreeDisplay, the adaptee is any\nhierarchical structure. A minimalist interface might include two\noperations, one that defines how to present a node in the hierarchical\nstructure graphically, and another that retrieves the node's children.\nThe narrow interface leads to three implementation approaches:\na. Using abstract operations. Define corresponding abstract operations\nfor the narrow Adaptee interface in the TreeDisplay class.\nSubclasses must implement the abstract operations and adapt the\nhierarchically structured object. For example, a\nDirectoryTreeDisplay subclass will implement these operations by\naccessing the directory structure.\nDirectoryTreeDisplay specializes the narrow interface so that it\ncan display directory structures made up of FileSystemEntity\nobjects.\nb. Using delegate objects. In this approach, TreeDisplay forwards\nrequests for accessing the hierarchical structure to a delegate\nobject. TreeDisplay can use a different adaptation strategy by\nsubstituting a different delegate.\nFor example, suppose there exists a DirectoryBrowser that uses a\nTreeDisplay. DirectoryBrowser might make a good delegate for\nadapting TreeDisplay to the hierarchical directory structure. In\ndynamically typed languages like Smalltalk or Objective C, this\napproach only requires an interface for registering the delegate\nwith the adapter. Then TreeDisplay simply forwards the requests to\nthe delegate. NEXTSTEP [Add94] uses this approach heavily to reduce\nsubclassing.\nStatically typed languages like C++ require an explicit interface\ndefinition for the delegate. We can specify such an interface by\nputting the narrow interface that TreeDisplay requires into an\nabstract TreeAccessorDelegate class. Then we can mix this interface\ninto the delegate of our choice\u2014DirectoryBrowser in this case\u2014using\ninheritance. We use single inheritance if the DirectoryBrowser has\nno existing parent class, multiple inheritance if it does. Mixing\nclasses together like this is easier than introducing a new\nTreeDisplay subclass and implementing its operations individually.\nc. Parameterized adapters. The usual way to support pluggable adapters\nin Smalltalk is to parameterize an adapter with one or more blocks.\nThe block construct supports adaptation without subclassing. A block\ncan adapt a request, and the adapter can store a block for each\nindividual request. In our example, this means TreeDisplay stores\none block for converting a node into a GraphicNode and another block\nfor accessing a node's children.\nFor example, to create TreeDisplay on a directory hierarchy, we write\n directoryDisplay :=\n (TreeDisplay on: treeRoot)\n getChildrenBlock:\n [:node | node getSubdirectories]\n createGraphicNodeBlock:\n [:node | node createGraphicNode].\nIf you're building interface adaptation into a class, this approach\noffers a convenient alternative to subclassing.",
  "Motivation": "Sometimes a toolkit class that's designed for reuse isn't reusable only because\nits interface doesn't match the domain-specific interface an application requires.\nConsider for example a drawing editor that lets users draw and arrange graphical\nelements (lines, polygons, text, etc.) into pictures and diagrams. The drawing\neditor's key abstraction is the graphical object, which has an editable shape\nand can draw itself. The interface for graphical objects is defined by an abstract\nclass called Shape. The editor defines a subclass of Shape for each kind of graphical\nobject: a LineShape class for lines, a PolygonShape class for polygons, and so\nforth.\nClasses for elementary geometric shapes like LineShape and PolygonShape are rather\neasy to implement, because their drawing and editing capabilities are inherently\nlimited. But a TextShape subclass that can display and edit text is considerably\nmore difficult to implement, since even basic text editing involves complicated\nscreen update and buffer management. Meanwhile, an off-the-shelf user interface\ntoolkit might already provide a sophisticated TextView class for displaying and\nediting text. Ideally we'd like to reuse TextView to implement TextShape, but\nthe toolkit wasn't designed with Shape classes in mind. So we can't use TextView\nand Shape objects interchangeably.\nHow can existing and unrelated classes like TextView work in an application that\nexpects classes with a different and incompatible interface? We could change the\nTextView class so that it conforms to the Shape interface, but that isn't an option\nunless we have the toolkit's source code. Even if we did, it wouldn't make sense\nto change TextView; the toolkit shouldn't have to adopt domain-specific interfaces\njust to make one application work.\nInstead, we could define TextShape so that it adapts the TextView interface to\nShape's. We can do this in one of two ways: (1) by inheriting Shape's interface\nand TextView's implementation or (2) by composing a TextView instance within a\nTextShape and implementing TextShape in terms of TextView's interface. These two\napproaches correspond to the class and object versions of the Adapter pattern.\nWe call TextShape an adapter.\nThis diagram illustrates the object adapter case. It shows how BoundingBox requests,\ndeclared in class Shape, are converted to GetExtent requests defined in TextView.\nSince TextShape adapts TextView to the Shape interface, the drawing editor can\nreuse the otherwise incompatible TextView class.\nOften the adapter is responsible for functionality the adapted class doesn't\nprovide. The diagram shows how an adapter can fulfill such responsibilities. The\nuser should be able to \"drag\" every Shape object to a new location interactively,\nbut TextView isn't designed to do that. TextShape can add this missing\nfunctionality by implementing Shape's CreateManipulator operation, which returns\nan instance of the appropriate Manipulator subclass.\nManipulator is an abstract class for objects that know how to animate a Shape\nin response to user input, like dragging the shape to a new location. There are\nsubclasses of Manipulator for different shapes; TextManipulator, for example,\nis the corresponding subclass for TextShape. By returning a TextManipulator\ninstance, TextShape adds the functionality that TextView lacks but Shape requires.",
  "Sample Code": "---\nWe\u2019ll give a brief sketch of the implementation of class and object adapters for the **Motivation** example, beginning with the classes `Shape` and `TextView`.\n```cpp\nclass Shape {\npublic:\n    Shape();\n    virtual void BoundingBox(Point& bottomLeft, Point& topRight) const;\n    virtual Manipulator* CreateManipulator() const;\n};\nclass TextView {\npublic:\n    TextView();\n    void GetOrigin(Coord& x, Coord& y) const;\n    void GetExtent(Coord& width, Coord& height) const;\n    virtual bool IsEmpty() const;\n};\n```\n`Shape` assumes a bounding box defined by its opposing corners. In contrast, `TextView` is defined by an origin, height, and width. `Shape` also defines a `CreateManipulator` operation for creating a `Manipulator` object, which knows how to animate a shape when the user manipulates it. `TextView` has no equivalent operation.\nThe class `TextShape` is an **adapter** between these different interfaces.\n---\n### Class Adapter\nA **class adapter** uses multiple inheritance to adapt interfaces. The key to class adapters is to use one inheritance branch to inherit the interface and another branch to inherit the implementation. The usual way to make this distinction in C++ is to inherit the interface publicly and inherit the implementation privately. We\u2019ll use this convention to define the `TextShape` adapter.\n```cpp\nclass TextShape : public Shape, private TextView {\npublic:\n    TextShape();\n    virtual void BoundingBox(Point& bottomLeft, Point& topRight) const;\n    virtual bool IsEmpty() const;\n    virtual Manipulator* CreateManipulator() const;\n};\n```\nThe `BoundingBox` operation converts `TextView`\u2019s interface to conform to `Shape`\u2019s:\n```cpp\nvoid TextShape::BoundingBox(Point& bottomLeft, Point& topRight) const {\n    Coord bottom, left, width, height;\n    GetOrigin(bottom, left);\n    GetExtent(width, height);\n    bottomLeft = Point(bottom, left);\n    topRight = Point(bottom + height, left + width);\n}\n```\nThe `IsEmpty` operation demonstrates the direct forwarding of requests, which is common in adapter implementations:\n```cpp\nbool TextShape::IsEmpty() const {\n    return TextView::IsEmpty();\n}\n```\nFinally, we define `CreateManipulator` (which isn\u2019t supported by `TextView`) from scratch. Assume we\u2019ve already implemented a `TextManipulator` class that supports manipulation of a `TextShape`.\n```cpp\nManipulator* TextShape::CreateManipulator() const {\n    return new TextManipulator(this);\n}\n```\n---\n### Object Adapter\nThe **object adapter** uses object composition to combine classes with different interfaces. In this approach, the adapter `TextShape` maintains a pointer to `TextView`.\n```cpp\nclass TextShape : public Shape {\npublic:\n    TextShape(TextView*);\n    virtual void BoundingBox(Point& bottomLeft, Point& topRight) const;\n    virtual bool IsEmpty() const;\n    virtual Manipulator* CreateManipulator() const;\nprivate:\n    TextView* _text;\n};\n```\n`TextShape` must initialize the pointer to the `TextView` instance in the constructor. It must also call operations on its `TextView` object whenever its own operations are called. In this example, assume that the client creates the `TextView` object and passes it to the `TextShape` constructor:\n```cpp\nTextShape::TextShape(TextView* t) {\n    _text = t;\n}\n```\n```cpp\nvoid TextShape::BoundingBox(Point& bottomLeft, Point& topRight) const {\n    Coord bottom, left, width, height;\n    _text->GetOrigin(bottom, left);\n    _text->GetExtent(width, height);\n    bottomLeft = Point(bottom, left);\n    topRight = Point(bottom + height, left + width);\n}\n```\n```cpp\nbool TextShape::IsEmpty() const {\n    return _text->IsEmpty();\n}\n```\n`CreateManipulator`'s implementation doesn\u2019t change from the class adapter version, since it\u2019s implemented from scratch and doesn\u2019t reuse any existing `TextView` functionality.\n```cpp\nManipulator* TextShape::CreateManipulator() const {\n    return new TextManipulator(this);\n}\n```\n---\n### Summary\nCompare this code to the class adapter case. The object adapter requires a little more effort to write, but it\u2019s more flexible. For example, the object adapter version of `TextShape` will work equally well with subclasses of `TextView`\u2014the client simply passes an instance of a `TextView` subclass to the `TextShape` constructor.\n---"
}