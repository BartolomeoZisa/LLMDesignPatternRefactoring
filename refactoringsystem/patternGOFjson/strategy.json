{
  "Intent": "Define a family of algorithms, encapsulate each one, and make them interchangeable.\nStrategy lets the algorithm vary independently fromclients that use it.",
  "Motivation": "Many algorithms exist for breaking a stream of text into lines.Hard-wiring all\nsuch algorithms into the classes that require them isn't desirable for several\nreasons:\n\u00b7 Clients that need line breaking get more complex if they include the\nline breaking code. That makes clients bigger and harder to maintain,\nespecially if they support multiple line breaking algorithms.\n\u00b7 Different algorithms will be appropriate at different times. We don't want\nto support multiple line breaking algorithms if we don't use thermally.\n\u00b7 It's difficult to add new algorithms and vary existing ones when line breaking\nis an integral part of a client.\nWe can avoid these problems by defining classes that encapsulate different\nline breaking algorithms. An algorithm that's encapsulated in this way is called\na strategy.\nSuppose a Composition class is responsible for maintaining and updating the\nline breaks of text displayed in a text viewer.Line breaking strategies aren't\nimplemented by the class Composition.Instead, they are implemented separately\nby subclasses of the abstractCompositor class. Compositor subclasses implement\ndifferent strategies:\n\u00b7 SimpleCompositorimplements a simple strategy that determines linebreaks\none at time.\n\u00b7 TeXCompositorimplements the TeX algorithm for finding linebreaks. This\nstrategy tries to optimize linebreaks globally, that is, one paragraph at\ntime.\n\u00b7 ArrayCompositorimplements a strategy that selects breaks so that each row\nhas a fixed number of items. It's useful for breaking a collection of icons\ninto rows, for example.\nA Composition maintains a reference to a Compositor object. Whenever a Composition\nreformats its text, it forwards this responsibility to its Compositor object. The\nclient of Composition specifies which Compositor should be used by installing the\nCompositor it desires into the Composition.",
  "Structure": "@startuml\ntitle Strategy Pattern\n' ==== Strategy Interface ====\ninterface Strategy {\n    +execute(): void\n}\n' ==== Concrete Strategies ====\nclass ConcreteStrategyA implements Strategy {\n    +execute(): void\n}\nclass ConcreteStrategyB implements Strategy {\n    +execute(): void\n}\nclass ConcreteStrategyC implements Strategy {\n    +execute(): void\n}\n' ==== Context ====\nclass Context {\n    -strategy: Strategy\n    +setStrategy(s: Strategy): void\n    +performAction(): void\n}\n' ==== Relationships ====\nContext --> Strategy : uses\n@enduml",
  "Participants": "\u00b7 Strategy (Compositor)\no declares an interface common to all supported algorithms. Context\nuses this interface to call the algorithm defined by a\nConcreteStrategy.\n\u00b7 ConcreteStrategy (SimpleCompositor, TeXCompositor,ArrayCompositor)\no implements the algorithm using the Strategy interface.\n\u00b7 Context (Composition)\no is configured with a ConcreteStrategy object.\no maintains a reference to a Strategy object.\no may define an interface that lets Strategy access its data.",
  "Collaborations": "\u00b7 Strategy and Context interact to implement the chosen algorithm. Context\nmay pass all data required by the algorithm to the strategy when the algorithm\nis called. Alternatively, the context can pass itself as an argument to\nStrategy operations. That lets the strategically back on the context as\nrequired.\n\u00b7 A context forwards requests from its clients to its strategy. Clients usually\ncreate and pass a ConcreteStrategy object to the context;thereafter,\nclients interact with the context exclusively. There soften a family of\nConcreteStrategy classes for a client to choose from.",
  "Implementation": "Consider the following implementation issues:\n1. Defining the Strategy and Context interfaces.The Strategy and Context\ninterfaces must give a ConcreteStrategy efficient access to any data it needs\nfrom a context, and vice versa.\nOne approach is to have Context pass data in parameters to\nStrategy operations\u2014in other words, take the data to the strategy. This\nkeeps Strategy and Context decoupled. On the other hand, Context might pass\ndata the Strategy doesn't need.\nAnother technique has a context pass itself as an argument, and the strategy\nrequests data from the context explicitly.Alternatively, the strategy can\nstore a reference to its context,eliminating the need to pass anything at\nall. Either way, the strategy can request exactly what it needs. But now\nContext must define a more elaborate interface to its data, which couples\nStrategy and Context more closely.\nThe needs of the particular algorithm and its data requirements\nwill determine the best technique.\n2. Strategies as template parameters.In C++ templates can be used to configure\na class with a strategy.This technique is only applicable if (1) the Strategy\ncan be selected at compile-time, and (2) it does not have to be changed at\nrun-time.In this case, the class to be configured (e.g., Context) is defined\nas a template class that has a Strategy class as parameter:\ntemplate <class AStrategy>\nclass Context {\nvoid Operation() { theStrategy.DoAlgorithm(); }\n// ...\nprivate:\nAStrategy theStrategy;\n};\nThe class is then configured with a Strategy class when it's\ninstantiated:\nclass MyStrategy {\npublic:\nvoid DoAlgorithm();\n};\nContext<MyStrategy> aContext;\nWith templates, there's no need to define an abstract class that defines\nthe interface to the Strategy. Using Strategy as atemplate parameter also\nlets you bind a Strategy to its Context statically, which can increase\nefficiency.\n3. Making Strategy objects optional.The Context class may be simplified if\nit's meaningful not Mohave a Strategy object. Context checks to see if it\nhas a Strategyobject before accessing it. If there is one, then Context\nuses it normally. If there isn't a strategy, then Context carries out\ndefault behavior. The benefit of this approach is that clients don't have\ntidal with Strategy objects at all unless they don't like the default\nbehavior.",
  "Sample Code": "---\nWe'll give the high-level code for the Motivation example, which is based on the implementation of the `Composition` and `Compositor` classes in *InterViews* [LCI+92]. The `Composition` class maintains a collection of `Component` instances, which represent text and graphical elements in a document. A composition arranges component objects into lines using an instance of a `Compositor` subclass, which encapsulates a line-breaking strategy. Each component has an associated natural size, stretchability, and shrinkability. The stretchability defines how much the component can grow beyond its natural size, and shrinkability is how much it can shrink. The composition passes these values to a compositor, which uses them to determine the best location for line breaks.\n### Composition Class:\n```cpp\nclass Composition {\npublic:\n    Composition(Compositor*);\n    void Repair();\nprivate:\n    Compositor* _compositor;\n    Component* _components;  // the list of components\n    int _componentCount;     // the number of components\n    int _lineWidth;          // the Composition's line width\n    int* _lineBreaks;        // the position of line breaks in components\n    int _lineCount;          // the number of lines\n};\n```\nWhen a new layout is required, the composition asks its compositor to determine where to place line breaks. The composition passes the compositor three arrays that define natural sizes, stretchabilities, and shrinkabilities of the components. It also passes the number of components, how wide the line is, and an array that the compositor fills with the position of each line break. The compositor returns the number of calculated breaks.\nThe `Compositor` interface lets the composition pass the compositor all the information it needs. This is an example of \"taking the data to the strategy\":\n### Compositor Interface:\n```cpp\nclass Compositor {\npublic:\n    virtual int Compose(\n        Coord natural[], Coord stretch[], Coord shrink[],\n        int componentCount, int lineWidth, int breaks[]\n    ) = 0;\nprotected:\n    Compositor();\n};\n```\nNote that `Compositor` is an abstract class. Concrete subclasses define specific line-breaking strategies. The composition calls its compositor in its `Repair` operation. `Repair` first initializes arrays with the natural size, stretchability, and shrinkability of each component (the details of which we omit for brevity). Then it calls on the compositor to obtain the line breaks and finally lays out the components according to the breaks (also omitted):\n### Repair Method:\n```cpp\nvoid Composition::Repair() {\n    Coord* natural;\n    Coord* stretchability;\n    Coord* shrinkability;\n    int componentCount;\n    int* breaks;\n    // prepare the arrays with the desired component sizes\n    // ...\n    // determine where the breaks are:\n    int breakCount;\n    breakCount = _compositor->Compose(\n        natural, stretchability, shrinkability,\n        componentCount, _lineWidth, breaks\n    );\n    // lay out components according to breaks\n    // ...\n}\n```\nNow let's look at the `Compositor` subclasses.\n### SimpleCompositor Class:\n```cpp\nclass SimpleCompositor : public Compositor {\npublic:\n    SimpleCompositor();\n    virtual int Compose(\n        Coord natural[], Coord stretch[], Coord shrink[],\n        int componentCount, int lineWidth, int breaks[]\n    );\n    // ...\n};\n```\n`TeXCompositor` uses a more global strategy. It examines a paragraph at a time, taking into account the components' size and stretchability. It also tries to give an even \"color\" to the paragraph by minimizing the whitespace between components.\n### TeXCompositor Class:\n```cpp\nclass TeXCompositor : public Compositor {\npublic:\n    TeXCompositor();\n    virtual int Compose(\n        Coord natural[], Coord stretch[], Coord shrink[],\n        int componentCount, int lineWidth, int breaks[]\n    );\n    // ...\n};\n```\n`ArrayCompositor` breaks the components into lines at regular intervals.\n### ArrayCompositor Class:\n```cpp\nclass ArrayCompositor : public Compositor {\npublic:\n    ArrayCompositor(int interval);\n    virtual int Compose(\n        Coord natural[], Coord stretch[], Coord shrink[],\n        int componentCount, int lineWidth, int breaks[]\n    );\n    // ...\n};\n```\nThese classes don't use all the information passed in `Compose`. `SimpleCompositor` ignores the stretchability of the components, taking only their natural widths into account. `TeXCompositor` uses all the information passed to it, whereas `ArrayCompositor` ignores everything.\nTo instantiate `Composition`, you pass it the compositor you want to use:\n```cpp\nComposition* quick = new Composition(new SimpleCompositor);\nComposition* slick = new Composition(new TeXCompositor);\nComposition* iconic = new Composition(new ArrayCompositor(100));\n```\nThe `Compositor`'s interface is carefully designed to support all layout algorithms that subclasses might implement. You don't want to have to change this interface with every new subclass, because that will require changing existing subclasses. In general, the Strategy and Context interfaces determine how well the pattern achieves its intent.\n---"
}