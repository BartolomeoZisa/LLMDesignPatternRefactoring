{
  "Intent": "Define a family of algorithms, encapsulate each one, and make theminterchangeable.\nStrategy lets the algorithm vary independently fromclients that use it.",
  "Motivation": "Many algorithms exist for breaking a stream of text into lines.Hard-wiring all\nsuch algorithms into the classes that require themisn't desirable for several\nreasons:\n\u00b7 Clients that need linebreaking get more complex if they includethe\nlinebreaking code. That makes clients bigger and harder tomaintain,\nespecially if they support multiple linebreaking algorithms.\n\u00b7 Different algorithms will be appropriate at different times. We don'twant\nto support multiple linebreaking algorithms if we don't use themall.\n\u00b7 It's difficult to add new algorithms and vary existing ones whenlinebreaking\nis an integral part of a client.\nWe can avoid these problems by defining classes that encapsulatedifferent\nlinebreaking algorithms. An algorithm that's encapsulated inthis way is called\na strategy.\nSuppose a Composition class is responsible for maintaining andupdating the\nlinebreaks of text displayed in a text viewer.Linebreaking strategies aren't\nimplemented by the class Composition.Instead, they are implemented separately\nby subclasses of the abstractCompositor class. Compositor subclasses implement\ndifferent strategies:\n\u00b7 SimpleCompositorimplements a simple strategy that determines linebreaks\none at atime.\n\u00b7 TeXCompositorimplements the TeX algorithm for finding linebreaks. This\nstrategytries to optimize linebreaks globally, that is, one paragraph at\natime.\n\u00b7 ArrayCompositorimplements a strategy that selects breaks so that each row\nhas a fixednumber of items. It's useful for breaking a collection of icons\nintorows, for example.\nA Composition maintains a reference to a Compositor object. Whenever aComposition\nreformats its text, it forwards this responsibility to itsCompositor object. The\nclient of Composition specifies whichCompositor should be used by installing the\nCompositor it desires intothe Composition.",
  "Structure": "@startuml\ntitle Strategy Pattern\n' ==== Strategy Interface ====\ninterface Strategy {\n    +execute(): void\n}\n' ==== Concrete Strategies ====\nclass ConcreteStrategyA implements Strategy {\n    +execute(): void\n}\nclass ConcreteStrategyB implements Strategy {\n    +execute(): void\n}\nclass ConcreteStrategyC implements Strategy {\n    +execute(): void\n}\n' ==== Context ====\nclass Context {\n    -strategy: Strategy\n    +setStrategy(s: Strategy): void\n    +performAction(): void\n}\n' ==== Relationships ====\nContext --> Strategy : uses\n@enduml",
  "Participants": "\u00b7 Strategy (Compositor)\no declares an interface common to all supported algorithms. Context\nuses this interface to call the algorithm defined by a\nConcreteStrategy.\n\u00b7 ConcreteStrategy (SimpleCompositor, TeXCompositor,ArrayCompositor)\no implements the algorithm using the Strategy interface.\n\u00b7 Context (Composition)\no is configured with a ConcreteStrategy object.\no maintains a reference to a Strategy object.\no may define an interface that lets Strategy access its data.",
  "Collaborations": "\u00b7 Strategy and Context interact to implement the chosen algorithm. Acontext\nmay pass all data required by the algorithm to the strategywhen the algorithm\nis called. Alternatively, the context can passitself as an argument to\nStrategy operations. That lets the strategycall back on the context as\nrequired.\n\u00b7 A context forwards requests from its clients to its strategy. Clientsusually\ncreate and pass a ConcreteStrategy object to the context;thereafter,\nclients interact with the context exclusively. There isoften a family of\nConcreteStrategy classes for a client to choosefrom.",
  "Implementation": "Consider the following implementation issues:\n1. Defining the Strategy and Context interfaces.The Strategy and Context\ninterfaces must give a ConcreteStrategyefficient access to any data it needs\nfrom a context, and vice versa.\nOne approach is to have Context pass data in parameters to\nStrategyoperations\u2014in other words, take the data to the strategy. This\nkeepsStrategy and Context decoupled. On the other hand, Context mightpass\ndata the Strategy doesn't need.\nAnother technique has a context pass itself as an argument, andthe strategy\nrequests data from the context explicitly.Alternatively, the strategy can\nstore a reference to its context,eliminating the need to pass anything at\nall. Either way, thestrategy can request exactly what it needs. But now\nContext mustdefine a more elaborate interface to its data, which couples\nStrategyand Context more closely.\nThe needs of the particular algorithm and its data requirements\nwilldetermine the best technique.\n2. Strategies as template parameters.In C++ templates can be used to configure\na class with a strategy.This technique is only applicable if (1) the Strategy\ncan be selectedat compile-time, and (2) it does not have to be changed at\nrun-time.In this case, the class to be configured (e.g., Context) isdefined\nas a template class that has a Strategy class as aparameter:\ntemplate <class AStrategy>\nclass Context {\nvoid Operation() { theStrategy.DoAlgorithm(); }\n// ...\nprivate:\nAStrategy theStrategy;\n};\nThe class is then configured with a Strategy class when it's\ninstantiated:\nclass MyStrategy {\npublic:\nvoid DoAlgorithm();\n};\nContext<MyStrategy> aContext;\nWith templates, there's no need to define an abstract class that defines\nthe interface to the Strategy. Using Strategy as atemplate parameter also\nlets you bind a Strategy to itsContext statically, which can increase\nefficiency.\n3. Making Strategy objects optional.The Context class may be simplified if\nit's meaningful not tohave a Strategy object. Context checks to see if it\nhas a Strategyobject before accessing it. If there is one, then Context\nuses itnormally. If there isn't a strategy, then Context carries out\ndefaultbehavior. The benefit of this approach is that clients don't have\ntodeal with Strategy objects at all unless they don't like thedefault\nbehavior.",
  "Sample Code": "We'll give the high-level code for the Motivation example, which isbased on the\nimplementation of Composition and Compositor classes inInterViews [LCI+92].\nThe Composition class maintains a collection ofComponent instances, which\nrepresent text and graphicalelements in a document. A composition arranges\ncomponent objects intolines using an instance of a Compositor subclass,\nwhichencapsulates a linebreaking strategy. Each component has anassociated\nnatural size, stretchability, and shrinkability. Thestretchability defines how\nmuch the component can grow beyond itsnatural size; shrinkability is how much\nit can shrink. Thecomposition passes these values to a compositor, which uses\nthem todetermine the best location for linebreaks.\nclass Composition {\npublic:\nComposition(Compositor*);\nvoid Repair();\nprivate:\nCompositor* _compositor;\nComponent* _components; // the list of components\nint _componentCount; // the number of components\nint _lineWidth; // the Composition's line width\nint* _lineBreaks; // the position of linebreaks\n // in components\nint _lineCount; // the number of lines\n};\nWhen a new layout is required, the composition asks its compositor todetermine\nwhere to place linebreaks. The composition passes thecompositor three arrays that\ndefine natural sizes, stretchabilities,and shrinkabilities of the components.\nIt also passes the number ofcomponents, how wide the line is, and an array that\nthe compositorfills with the position of each linebreak. The compositor returns\nthenumber of calculated breaks.\nThe Compositor interface lets the composition pass thecompositor all the\ninformation it needs. This is an example of\"taking the data to the strategy\":\nclass Compositor {\npublic:\nvirtual int Compose(\nCoord natural[], Coord stretch[], Coord shrink[],\nint componentCount, int lineWidth, int breaks[]\n) = 0;\nprotected:\nCompositor();\n};\nNote that Compositor is an abstract class. Concretesubclasses define specific\nlinebreaking strategies.\nThe composition calls its compositor in its Repairoperation. Repair first\ninitializes arrays with the naturalsize, stretchability, and shrinkability of\neach component (the detailsof which we omit for brevity). Then it calls on the\ncompositor toobtain the linebreaks and finally lays out the components according\ntothe breaks (also omitted):\nvoid Composition::Repair () {\nCoord* natural;\nCoord* stretchability;\nCoord* shrinkability;\nint componentCount;\nint* breaks;\n// prepare the arrays with the desired component sizes\n// ...\n// determine where the breaks are:\nint breakCount;\nbreakCount = _compositor->Compose(\nnatural, stretchability, shrinkability,\ncomponentCount, _lineWidth, breaks\n);\n// lay out components according to breaks\n// ...\n}\nNow let's look at the Compositor subclasses.SimpleCompositor examines components\na line at a time todetermine where breaks should go:\nclass SimpleCompositor : public Compositor {\npublic:\nSimpleCompositor();\nvirtual int Compose(\nCoord natural[], Coord stretch[], Coord shrink[],\nint componentCount, int lineWidth, int breaks[]\n);\n// ...\n};\nTeXCompositor uses a more global strategy. It examines aparagraph at a time, taking\ninto account the components' sizeand stretchability. It also tries to give an\neven \"color\" to theparagraph by minimizing the whitespace between components.\nclass TeXCompositor : public Compositor {\npublic:\nTeXCompositor();\nvirtual int Compose(\nCoord natural[], Coord stretch[], Coord shrink[],\nint componentCount, int lineWidth, int breaks[]\n);\n// ...\n};\nArrayCompositor breaks the components into lines at regularintervals.\nclass ArrayCompositor : public Compositor {\npublic:\nArrayCompositor(int interval);\nvirtual int Compose(\nCoord natural[], Coord stretch[], Coord shrink[],\nint componentCount, int lineWidth, int breaks[]\n);\n// ...\n};\nThese classes don't use all the information passed inCompose. SimpleCompositor\nignores the stretchabilityof the components, taking only their natural widths\ninto account.TeXCompositor uses all the information passed to it,\nwhereasArrayCompositor ignores everything.\nTo instantiate Composition, you pass it the compositoryou want to use:\nComposition* quick = new Composition(new SimpleCompositor);\nComposition* slick = new Composition(new TeXCompositor);\nComposition* iconic = new Composition(new ArrayCompositor(100));\nCompositor's interface is carefully designed to support alllayout algorithms that\nsubclasses might implement. You don't want tohave to change this interface with\nevery new subclass, because that willrequire changing existing subclasses. In\ngeneral, the Strategy andContext interfaces determine how well the pattern\nachieves its intent."
}