{
  "Intent": "Attach additional responsibilities to an object dynamically. Decorators provide\na flexible alternative to subclassing for extending functionality.",
  "Motivation": "Sometimes we want to add responsibilities to individual objects, not to an entire\nclass. A graphical user interface toolkit, for example, should let you add\nproperties like borders or behaviors like scrolling to any user interface\ncomponent.\nOne way to add responsibilities is with inheritance. Inheriting a border from\nanother class puts a border around every subclass instance. This is inflexible,\nhowever, because the choice of border is made statically. A client can't control\nhow and when to decorate the component with a border.\nA more flexible approach is to enclose the component in another object that adds\nthe border. The enclosing object is called a decorator. The decorator conforms\nto the interface of the component it decorates so that its presence is transparent\nto the component's clients. The decorator forwards requests to the component and\nmay perform additional actions (such as drawing a border) before or after\nforwarding. Transparency lets you nest decorators recursively, thereby allowing\nan unlimited number of added responsibilities.\nFor example, suppose we have a TextView object that displays text in a window.\nTextView has no scroll bars by default, because we might not always need them.\nWhen we do, we can use a ScrollDecorator to add them. Suppose we also want to\nadd a thick black border around the TextView. We can use a BorderDecorator to\nadd this as well. We simply compose the decorators with the TextView to produce\nthe desired result.\nThe following object diagram shows how to compose a TextView object with\nBorderDecorator and ScrollDecorator objects to produce a bordered, scrollable\ntext view:\nThe ScrollDecorator and BorderDecorator classes are subclasses of Decorator, an\nabstract class for visual components that decorate other visual components.\nVisualComponent is the abstract class for visual objects. It defines their drawing\nand event handling interface. Note how the Decorator class simply forwards draw\nrequests to its component, and how Decorator subclasses can extend this operation.\nDecorator subclasses are free to add operations for specific functionality. For\nexample, ScrollDecorator's ScrollTo operation lets other objects scroll the\ninterface if they know there happens to be a ScrollDecorator object in the interface.\nThe important aspect of this pattern is that it lets decorators appear anywhere\na VisualComponent can. That way clients generally can't tell the difference between\na decorated component and an undecorated one, and so they don't depend at all\non the decoration.",
  "Structure": "@startuml\ntitle Decorator Pattern\ninterface Component {\n    +operation(): void\n}\nclass ConcreteComponent implements Component {\n    +operation(): void\n}\nabstract class Decorator implements Component {\n    -component: Component\n    +Decorator(component: Component)\n    +operation(): void\n}\nclass ConcreteDecoratorA extends Decorator {\n    +operation(): void\n    -addedBehaviorA(): void\n}\nclass ConcreteDecoratorB extends Decorator {\n    +operation(): void\n    -addedBehaviorB(): void\n}\n// Relationships\nComponent <|.. ConcreteComponent\nComponent <|.. Decorator\nDecorator <|-- ConcreteDecoratorA\nDecorator <|-- ConcreteDecoratorB\nDecorator --> Component : wraps\n@enduml",
  "Participants": "\u00b7 Component (VisualComponent)\no defines the interface for objects that can have responsibilities\nadded to them dynamically.\n\u00b7 ConcreteComponent (TextView)\no defines an object to which additional responsibilities can be\nattached.\n\u00b7 Decorator\no maintains a reference to a Component object and defines an interface\nthat conforms to Component's interface.\n\u00b7 ConcreteDecorator (BorderDecorator, ScrollDecorator)\no adds responsibilities to the component.",
  "Collaborations": "\u00b7 Decorator forwards requests to its Component object. It may optionally\nperform additional operations before and after forwarding the request.",
  "Implementation": "Several issues should be considered when applying the Decorator pattern:\n1. Interface conformance. A decorator object's interface must conform to the\ninterface of the component it decorates. ConcreteDecorator classes must\ntherefore inherit from a common class (at least in C++).\n2. Omitting the abstract Decorator class. There's no need to define an abstract\nDecorator class when you only need to add one responsibility. That's often\nthe case when you're dealing with an existing class hierarchy rather than\ndesigning a new one. In that case, you can merge Decorator's responsibility\nfor forwarding requests to the component into the ConcreteDecorator.\n3. Keeping Component classes lightweight. To ensure a conforming interface,\ncomponents and decorators must descend from a common Component class. It's\nimportant to keep this common class lightweight; that is, it should focus\non defining an interface, not on storing data. The definition of the data\nrepresentation should be deferred to subclasses; otherwise the complexity\nof the Component class might make the decorators too heavyweight to use\nin quantity. Putting a lot of functionality into Component also increases\nthe probability that concrete subclasses will pay for features they don't\nneed.\n4. Changing the skin of an object versus changing its guts. We can think of\na decorator as a skin over an object that changes its behavior. An\nalternative is to change the object's guts. The Strategy (349) pattern is\na good example of a pattern for changing the guts.\nStrategies are a better choice in situations where the Component class is\nintrinsically heavyweight, thereby making the Decorator pattern too costly\nto apply. In the Strategy pattern, the component forwards some of its\nbehavior to a separate strategy object. The Strategy pattern lets us alter\nor extend the component's functionality by replacing the strategy object.\nFor example, we can support different border styles by having the component\ndefer border-drawing to a separate Border object. The Border object is a\nStrategy object that encapsulates a border-drawing strategy. By extending\nthe number of strategies from just one to an open-ended list, we achieve\nthe same effect as nesting decorators recursively.\nIn MacApp 3.0 [App89] and Bedrock [Sym93a], for example, graphical\ncomponents (called \"views\") maintain a list of \"adorner\" objects that can\nattach additional adornments like borders to a view component. If a view\nhas any adorners attached, then it gives them a chance to draw additional\nembellishments. MacApp and Bedrock must use this approach because the View\nclass is heavyweight. It would be too expensive to use a full-fledged View\njust to add a border.\nSince the Decorator pattern only changes a component from the outside, the\ncomponent doesn't have to know anything about its decorators; that is, the\ndecorators are transparent to the component:\nWith strategies, the component itself knows about possible extensions. So\nit has to reference and maintain the corresponding strategies:\nThe Strategy-based approach might require modifying the component to\naccommodate new extensions. On the other hand, a strategy can have its own\nspecialized interface, whereas a decorator's interface must conform to the\ncomponent's. A strategy for rendering a border, for example, need only\ndefine the interface for rendering a border (DrawBorder, GetWidth, etc.),\nwhich means that the strategy can be lightweight even if the Component class\nis heavyweight.\nMacApp and Bedrock use this approach for more than just adorning views.\nThey also use it to augment the event-handling behavior of objects. In both\nsystems, a view maintains a list of \"behavior\" objects that can modify and\nintercept events. The view gives each of the registered behavior objects\na chance to handle the event before nonregistered behaviors, effectively\noverriding them. You can decorate a view with special keyboard-handling\nsupport, for example, by registering a behavior object that intercepts and\nhandles key events.",
  "Sample Code": "---\nThe following code shows how to implement user interface decorators in C++. We'll assume there's a `Component` class called `VisualComponent`.\n```cpp\nclass VisualComponent {\npublic:\n    VisualComponent();\n    virtual void Draw();\n    virtual void Resize();\n    // ...\n};\n```\nWe define a subclass of `VisualComponent` called `Decorator`, which we'll subclass to obtain different decorations.\n```cpp\nclass Decorator : public VisualComponent {\npublic:\n    Decorator(VisualComponent*);\n    virtual void Draw();\n    virtual void Resize();\n    // ...\nprivate:\n    VisualComponent* _component;\n};\n```\n`Decorator` decorates the `VisualComponent` referenced by the `_component` instance variable, which is initialized in the constructor. For each operation in `VisualComponent`'s interface, `Decorator` defines a default implementation that passes the request on to `_component`:\n```cpp\nvoid Decorator::Draw() {\n    _component->Draw();\n}\nvoid Decorator::Resize() {\n    _component->Resize();\n}\n```\nSubclasses of `Decorator` define specific decorations. For example, the class `BorderDecorator` adds a border to its enclosing component. `BorderDecorator` is a subclass of `Decorator` that overrides the `Draw` operation to draw the border. `BorderDecorator` also defines a private `DrawBorder` helper operation that does the drawing. The subclass inherits all other operation implementations from `Decorator`.\n```cpp\nclass BorderDecorator : public Decorator {\npublic:\n    BorderDecorator(VisualComponent*, int borderWidth);\n    virtual void Draw();\nprivate:\n    void DrawBorder(int);\nprivate:\n    int _width;\n};\nvoid BorderDecorator::Draw() {\n    Decorator::Draw();\n    DrawBorder(_width);\n}\n```\nA similar implementation would follow for `ScrollDecorator` and `DropShadowDecorator`, which would add scrolling and drop shadow capabilities to a visual component.\nNow we can compose instances of these classes to provide different decorations. The following code illustrates how we can use decorators to create a bordered scrollable `TextView`.\nFirst, we need a way to put a visual component into a window object. We'll assume our `Window` class provides a `SetContents` operation for this purpose:\n```cpp\nvoid Window::SetContents(VisualComponent* contents) {\n    // ...\n}\n```\nNow we can create the text view and a window to put it in:\n```cpp\nWindow* window = new Window;\nTextView* textView = new TextView;\n```\n`TextView` is a `VisualComponent`, which lets us put it into the window:\n```cpp\nwindow->SetContents(textView);\n```\nBut we want a bordered and scrollable `TextView`. So we decorate it accordingly before putting it in the window.\n```cpp\nwindow->SetContents(\n    new BorderDecorator(\n        new ScrollDecorator(textView), 1\n    )\n);\n```\nBecause `Window` accesses its contents through the `VisualComponent` interface, it's unaware of the decorator's presence. You, as the client, can still keep track of the text view if you have to interact with it directly, for example, when you need to invoke operations that aren't part of the `VisualComponent` interface. Clients that rely on the component's identity should refer to it directly as well."
}