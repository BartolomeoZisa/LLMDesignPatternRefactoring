{
  "Intent": "Define an interface for creating an object, but let subclasses decide which class\nto instantiate. Factory Method lets a class defer instantiation to subclasses.",
  "Motivation": "Frameworks use abstract classes to define and maintain relationships between\nobjects. A framework is often responsible for creating these objects as well.\nConsider a framework for applications that can present multiple documents to the\nuser. Two key abstractions in this framework are the classes Application and\nDocument. Both classes are abstract, and clients have to subclass them to realize\ntheir application-specific implementations. To create a drawing application, for\nexample, we define the classes DrawingApplication and DrawingDocument. The\nApplication class is responsible for managing Documents and will create them as\nrequired\u2014when the user selects Open or New from a menu, for example.\nBecause the particular Document subclass to instantiate is application-specific,\nthe Application class can't predict the subclass of Document to instantiate\u2014the\nApplication class only knows when a new document should be created, not what kind\nof Document to create. This creates a dilemma: The framework must instantiate\nclasses, but it only knows about abstract classes, which it cannot instantiate.\nThe Factory Method pattern offers a solution. It encapsulates the knowledge of\nwhich Document subclass to create and moves this knowledge out of the framework.\nApplication subclasses redefine an abstract CreateDocument operation on\nApplication to return the appropriate Document subclass. Once an Application\nsubclass is instantiated, it can then instantiate application-specific Documents\nwithout knowing their class. We call CreateDocument a factory method because it's\nresponsible for \"manufacturing\" an object.",
  "Structure": "@startuml\ntitle Factory Method Pattern\n' Abstract Product\ninterface Product {\n    +use(): void\n}\n' Concrete Products\nclass ConcreteProductA implements Product {\n    +use(): void\n}\nclass ConcreteProductB implements Product {\n    +use(): void\n}\n' Creator (Factory)\nabstract class Creator {\n    +factoryMethod(): Product\n    +someOperation(): void\n}\n' Concrete Creators\nclass ConcreteCreatorA extends Creator {\n    +factoryMethod(): Product\n}\nclass ConcreteCreatorB extends Creator {\n    +factoryMethod(): Product\n}\n' Relationships\nCreator --> Product : \"creates\"\nConcreteCreatorA --> ConcreteProductA : \"creates\"\nConcreteCreatorB --> ConcreteProductB : \"creates\"\n@enduml",
  "Participants": "\u00b7 Product (Document)\no defines the interface of objects the factory method creates.\n\u00b7 ConcreteProduct (MyDocument)\no implements the Product interface.\n\u00b7 Creator (Application)\no declares the factory method, which returns an object of type Product.\nCreator may also define a default implementation of the factory\nmethod that returns a default ConcreteProduct object.\no may call the factory method to create a Product object.\n\u00b7 ConcreteCreator (MyApplication)\no overrides the factory method to return an instance of a\nConcreteProduct.",
  "Collaborations": "\u00b7 Creator relies on its subclasses to define the factory method so that it\nreturns an instance of the appropriate ConcreteProduct.",
  "Implementation": "Consider the following issues when applying the Factory Method pattern:\n1. Two major varieties. The two main variations of the Factory Method pattern\nare (1) the case when the Creator class is an abstract class and does not\nprovide an implementation for the factory method it declares, and (2) the\ncase when the Creator is a concrete class and provides a default\nimplementation for the factory method. It's also possible to have an\nabstract class that defines a default implementation, but this is less\ncommon.\nThe first case requires subclasses to define an implementation, because\nthere's no reasonable default. It gets around the dilemma of having to\ninstantiate unforeseeable classes. In the second case, the concrete Creator\nuses the factory method primarily for flexibility. It's following a rule\nthat says, \"Create objects in a separate operation so that subclasses can\noverride the way they're created.\" This rule ensures that designers of\nsubclasses can change the class of objects their parent class instantiates\nif necessary.\n2. Parameterized factory methods. Another variation on the pattern lets the\nfactory method create multiple kinds of products. The factory method takes\na parameter that identifies the kind of object to create. All objects the\nfactory method creates will share the Product interface. In the Document\nexample, Application might support different kinds of Documents. You pass\nCreateDocument an extra parameter to specify the kind of document to create.\nThe Unidraw graphical editing framework [VL90] uses this approach for\nreconstructing objects saved on disk. Unidraw defines a Creator class with\na factory method Create that takes a class identifier as an argument. The\nclass identifier specifies the class to instantiate. When Unidraw saves\nan object to disk, it writes out the class identifier first and then its\ninstance variables. When it reconstructs the object from disk, it reads\nthe class identifier first.\nOnce the class identifier is read, the framework calls Create, passing the\nidentifier as the parameter. Create looks up the constructor for the\ncorresponding class and uses it to instantiate the object. Last, Create\ncalls the object's Read operation, which reads the remaining information\non the disk and initializes the object's instance variables.\nA parameterized factory method has the following general form, where\nMyProduct and YourProduct are subclasses of Product:\n class Creator {\n public:\n virtual Product* Create(ProductId);\n };\n Product* Creator::Create (ProductId id) {\n if (id == MINE) return new MyProduct;\n if (id == YOURS) return new YourProduct;\n // repeat for remaining products...\n return 0;\n }\nOverriding a parameterized factory method lets you easily and selectively\nextend or change the products that a Creator produces. You can introduce\nnew identifiers for new kinds of products, or you can associate existing\nidentifiers with different products.\nFor example, a subclass MyCreator could swap MyProduct and YourProduct and\nsupport a new TheirProduct subclass:\n Product* MyCreator::Create (ProductId id) {\n if (id == YOURS) return new MyProduct;\n if (id == MINE) return new YourProduct;\n // N.B.: switched YOURS and MINE\n if (id == THEIRS) return new TheirProduct;\n return Creator::Create(id); // called if all others fail\n }\nNotice that the last thing this operation does is call Create on the parent\nclass. That's because MyCreator::Create handles only YOURS, MINE, and\nTHEIRS differently than the parent class. It isn't interested in other\nclasses. Hence MyCreator extends the kinds of products created, and it\ndefers responsibility for creating all but a few products to its parent.\n3. Language-specific variants and issues. Different languages lend themselves\nto other interesting variations and caveats.\nSmalltalk programs often use a method that returns the class of the object\nto be instantiated. A Creator factory method can use this value to create\na product, and a ConcreteCreator may store or even compute this value. The\nresult is an even later binding for the type of ConcreteProduct to be\ninstantiated.\nA Smalltalk version of the Document example can define a documentClass\nmethod on Application. The documentClass method returns the proper Document\nclass for instantiating documents. The implementation of documentClass in\nMyApplication returns the MyDocument class. Thus in class Application we\nhave\n clientMethod\n document := self documentClass new.\n documentClass\n self subclassResponsibility\nIn class MyApplication we have\n documentClass\n ^ MyDocument\nwhich returns the class MyDocument to be instantiated to Application.\nAn even more flexible approach akin to parameterized factory methods is\nto store the class to be created as a class variable of Application. That\nway you don't have to subclass Application to vary the product.\nFactory methods in C++ are always virtual functions and are often pure\nvirtual. Just be careful not to call factory methods in the Creator's\nconstructor\u2014the factory method in the ConcreteCreator won't be available\nyet.\nYou can avoid this by being careful to access products solely through\naccessor operations that create the product on demand. Instead of creating\nthe concrete product in the constructor, the constructor merely initializes\nit to 0. The accessor returns the product. But first it checks to make sure\nthe product exists, and if it doesn't, the accessor creates it. This\ntechnique is sometimes called lazy initialization. The following code shows\na typical implementation:\n class Creator {\n public:\n Product* GetProduct();\n protected:\n virtual Product* CreateProduct();\n private:\n Product* _product;\n };\n Product* Creator::GetProduct () {\n if (_product == 0) {\n _product = CreateProduct();\n }\n return _product;\n }\n4. Using templates to avoid subclassing. As we've mentioned, another potential\nproblem with factory methods is that they might force you to subclass just\nto create the appropriate Product objects. Another way to get around this\nin C++ is to provide a template subclass of Creator that's parameterized\nby the Product class:\n class Creator {\n public:\n virtual Product* CreateProduct() = 0;\n };\n template <class TheProduct>\n class StandardCreator: public Creator {\n public:\n virtual Product* CreateProduct();\n };\n template <class TheProduct>\n Product* StandardCreator<TheProduct>::CreateProduct () {\n return new TheProduct;\n }\nWith this template, the client supplies just the product class\u2014no\nsubclassing of Creator is required.\n class MyProduct : public Product {\n public:\n MyProduct();\n // ...\n };\n StandardCreator<MyProduct> myCreator;\n5. Naming conventions. It's good practice to use naming conventions that make\nit clear you're using factory methods. For example, the MacApp Macintosh\napplication framework [App89] always declares the abstract operation that\ndefines the factory method as Class* DoMakeClass(), where Class is the\nProduct class.",
  "Sample Code": "---\nThe function `CreateMaze` builds and returns a maze. One problem with this function is that it hard-codes the classes of maze, rooms, doors, and walls. We'll introduce factory methods to let subclasses choose these components.  \nFirst we'll define factory methods in `MazeGame` for creating the maze, room, wall, and door objects:\n```cpp\nclass MazeGame {\npublic:\n    Maze* CreateMaze();\n    // factory methods:\n    virtual Maze* MakeMaze() const {\n        return new Maze;\n    }\n    virtual Room* MakeRoom(int n) const {\n        return new Room(n);\n    }\n    virtual Wall* MakeWall() const {\n        return new Wall;\n    }\n    virtual Door* MakeDoor(Room* r1, Room* r2) const {\n        return new Door(r1, r2);\n    }\n};\n```\nEach factory method returns a maze component of a given type. `MazeGame` provides default implementations that return the simplest kinds of maze, rooms, walls, and doors.  \nNow we can rewrite `CreateMaze` to use these factory methods:\n```cpp\nMaze* MazeGame::CreateMaze() {\n    Maze* aMaze = MakeMaze();\n    Room* r1 = MakeRoom(1);\n    Room* r2 = MakeRoom(2);\n    Door* theDoor = MakeDoor(r1, r2);\n    aMaze->AddRoom(r1);\n    aMaze->AddRoom(r2);\n    r1->SetSide(North, MakeWall());\n    r1->SetSide(East, theDoor);\n    r1->SetSide(South, MakeWall());\n    r1->SetSide(West, MakeWall());\n    r2->SetSide(North, MakeWall());\n    r2->SetSide(East, MakeWall());\n    r2->SetSide(South, MakeWall());\n    r2->SetSide(West, theDoor);\n    return aMaze;\n}\n```\nDifferent games can subclass `MazeGame` to specialize parts of the maze. `MazeGame` subclasses can redefine some or all of the factory methods to specify variations in products. For example, a `BombedMazeGame` can redefine the `Room` and `Wall` products to return the bombed varieties:\n```cpp\nclass BombedMazeGame : public MazeGame {\npublic:\n    BombedMazeGame();\n    virtual Wall* MakeWall() const {\n        return new BombedWall;\n    }\n    virtual Room* MakeRoom(int n) const {\n        return new RoomWithABomb(n);\n    }\n};\n```\nAn `EnchantedMazeGame` variant might be defined like this:\n```cpp\nclass EnchantedMazeGame : public MazeGame {\npublic:\n    EnchantedMazeGame();\n    virtual Room* MakeRoom(int n) const {\n        return new EnchantedRoom(n, CastSpell());\n    }\n    virtual Door* MakeDoor(Room* r1, Room* r2) const {\n        return new DoorNeedingSpell(r1, r2);\n    }\nprotected:\n    Spell* CastSpell() const;\n};\n```\n---"
}